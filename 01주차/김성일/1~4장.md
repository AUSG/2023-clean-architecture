# 1장 설계와 아키텍쳐란?

>   사실 둘 사이에는 큰 차이가 없다.

-   아키텍처
    -   저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
-   설계
    -   저수준의 구조 또는 결정사항 등을 의미할 때가 많음

-   **저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소이다.**

    -   이 둘은 단절 될 수 없으며, 함께 대상 시스템의 구조를 정의

    -   이 둘을 구분하는 경계도 뚜렷하지 않으며, 고수준에서 저수준으로 향하는 의사결정의 연속성만 존재



## 좋은 소프트웨어 설계의 목표

>   소프트웨어 아키텍쳐의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는 것이 목표

설계 품질의 척도는 고객 요구를 만족시키는 데 드는 비용을 최소화하는데 드는 비용을 재는 척도와 다름이 없다!



## 사례 연구

>    한 기업의 사례를 통해, 엉망진창인 코드를 작성하게 될 때 발생할 수 있는 문제점을 설명

-   개발자들은 "지저분한 코드를 작성하면 단기간에는 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아진다" 라는 거짓말을 믿는다.

    -   실제로는 불가능에 가까움. 나중에 정리할 수 있다고 자신의 능력을 과신한 것.

    -   **엉망으로 만들면 깔끔하게 유지할 때 보다 항상 느리다.**

-   TDD를 적용했을 때, 장기적으로 본 결과 이터레이션별 걸린 시간이 TDD가 더 적음.
    -   **빨리 가는 유일한 방법은 제대로 가는 것이다.**



## 결론

어떤 경우라도 개발 조직이 할 수 있는 가장 최고의 선택지는 조직에 **스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 고민하는 것.**



# 2장 두 가지 가치에 대한 이야기

>   모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공. 그것이 행위와 구조.

-   소프트웨어 개발자는 **두 가지를 모두 반드시 높게 유지해야하는 책임을 진다.**
    -   대체로 개발자가 둘 중 덜 중요한 가치에 집중하여 결국에는 소프트웨어 시스템이 쓸모없게 된다.



## 행위

소프트웨어의 첫번째 가치는 행위이다. 

-   프로그래머는 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕느다.
-   이러한 요구사항을 기계가 위반하면, 프로그래머는 그 문제를 해결한다.

>   많은 프로그래머가 이러한 행동을 위한 활동이 자신이 해야 할 일의 전부라고 잘못 생각하고 있다.



## 아키텍쳐

>   소프트웨어가 본연의 목적을 추구하려면 소프트웨어는 반드시 부드러워야한다. 다시 말해 변경하기 쉬워야 한다.

-   변경사항을 간단하고 쉽게 적용할 수 있어야한다.
    -   변경사항을 적용하는 데 드는 어려움은 변경되는 **범위에 비례하며, 형태와는 관련이 없어야한다.**

-   이해관계자는 범위가 비슷한 일을 맡기지만, 소프트웨어의 형태는 계속하여 변경된다. 
    -   즉 새로운 요청사항이 발생할 때마다 시스템의 형태와 요구사항의 형태가 계속 맞지 않아, 그 요구사항을 적용하는 것이 계속 힘들어진다.
-   그렇기에 아키텍처는 **형태에 독립적이어야하고, 그럴수록 더욱 실용적이다.**



## 더 높은 가치

>   소프트웨어 시스템을 더 쉽게 변경할 수 있도록 하는 것이 더 중요하다.

-   업무 관리자는 시스템이 동작하는 것을 더 중요하게 여길 수 있다. 또, 개발자는 보통 이것에 동조한다. 하지만 이것은 잘못되었다.

-   완벽하게 동작하지만 수정이 아예 불가능한 프로그램이 된다면, 이 프로그램은 요구사항이 변경될 때 동작하지 않게되고 쓸모가 없어진다.
-   동작은 하지 않지만 변경이 쉬운 프로그램이라면, 프로그램이 돌아가도록 만들 수 있고 여전히 동작하도록 유지보수 할 수 있다. 계속 쓸모있는 채로 남을 것이다.



수정이 아예 불가능한 프로그램이란?

-   사실 수정이 아예 불가능한 프로그램은 거의 없다. 하지만, 변경을 위한 비용이 변경으로 창출되는 수익을 초과하는 경우 이것은 거의 수정이 불가능한 경우가 되어버린다.

만약 추후 업무 관리자에게 "변경 비용이 너무 커서 변경할 수 없다"라고 이야기하게 된다면?

-   "변경이 불가능한 상태에 처할 때까지 시스템을 방치했다."라며 화낼 가능성이 높다.



## 아이젠하워 매트릭스

>   두 가지 유형의 문제가 존재한다. 하나는 긴급하며, 다른하나는 중요하다. 긴급한 문제는 중요하지 않으며, 중요한 문제는 절대 긴급하지 않다.

-   소프트웨어의 첫 번째 가치인 행위는 긴급하지만 매번 높은 중요도를 가지지 않는다.
-   소프트웨어의 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.
-   물론 어떤 일은 긴급하며, 중요할 수 있다. 또한, 긴급하지도 않고 중요하지도 않은 일도 존재한다.



위 정리에 따른 일의 우선순위는 다음과 같다.

1.   긴급하고 중요한
2.   긴급하지 않지만 중요한
3.   긴급하지만 중요하지 않은
4.   긴급하지도 않고 중요하지도 않은 



-   즉, 중요한 일 ( 아키텍처 ) 은 1과 2에 해당하고 행위는 1과 3에 해당한다.

-   보통 업무관리자와 개발자는 3번의 일을 1번으로 격상시키는 경우가 많다. 즉, 긴급하고 중요한 일이 무엇인지를 인지하지 못하는 경우가 생긴다.
    -   **따라서 기능의 긴급성이 아닌 아키텍처의 중요성을 위해서는 소프트웨어 개발팀이 마땅히 책임을 져야한다.**



## 아키텍쳐를 위해 투쟁해라

>   이러한 책임을 다하려면, 투쟁해야한다. 아키텍처가 후순위가 되는 것을 용납했다면, 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 것이다.

-   효율적인 소프트웨어 개발 팀은 이러한 투쟁에서 정면으로 맞서 싸운다.
    -   이것이 소프트웨어의 개발자의 책무 중 하나이다.
-   하나만 기억하자. **아키텍처가 후순위가 되면 시스템 개발의 비용은 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.**



# 3장 패러다임 개요

-   구조적 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.



## 구조적 프로그래밍

>   제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

데이크스타라는 점프와 같은 프로그램 구조가 해롭다는 사실을 제시하면서, if/then/else와 do/while/until 과 같은 더 익숙한 구조로 대체하였다.



## 객체 지향 프로그래밍

>   제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.

요한 달과 크리스텐 니가드에 의해 등장했고, 알골의 함수 호출 스택 프레임을 힙으로 옮기면 지역변수가 오랫동안 유지될 수 있음을 발견하였다.

이를 통해, 클래스, 메서드, 인스턴스 변수, 다형성 등이 등장하게 되었다.



## 함수형 프로그래밍

>   할당문에 대해 규칙을 부과한다.

심볼의 값이 변경되지 않는다는 불변성의 개념을 도입했다. 이는 함수형 언어에는 할당문이 전혀 없다는 것이며, 변수 값을 변경하는 방법을 제공하긴 하지만 굉장히 까다로운 조건하에만 가능하다.



## 생각할 거리

-   각 패러다임은 프로그래머에게서 권한을 박탈하며, 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다.
    -   **즉, 무엇을 하면 안되는 지에 대한 이야기를 한다.**

위 세 패러다임은 우리에게 가져갈 수 있는 것들을 각각 가져가고 있으며, 이로 인해 **더이상 새로운 프로그래밍 패러다임은 나올 수 없을 것이다.**



## 결론

세 가지 패러다임과 아키텍처의 세 가지 큰 관심사 ( 함수, 컴포넌트 분리, 데이터 관리 ) 가 어떻게 연관되는지에 주목하자.



# 4장 구조적 프로그래밍

## 증명

-   데이크스타라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이였다.

-   프로그램은 단순하더라도, 너무 많은 세부사항을 담고 있었고 예상 외의 방식으로 실패하곤 했다.



>   데이크스트라는 증명이라는 수학적 원리를 통해, 입증된 구조를 이용하고 그것을 다시 코드와 결합시켜 스스로 증명하는 방식을 만드려했다.

-   이 과정중 goto와 같은 문장이 방해가 되는 경우가 있었고, 분기와 반복으로 대체할 수 있음을 알게되었다.



모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있음이 증명되으며 이를 통해 프로그램에서도 정리에 대한 유클리드 계층 구조를 만들 수 있을 것이라 생각되었다.



## 해로운 성명서

-   데이크스트라가 발표한 "goto문의 해로움"은 프로그래밍 세계에 전쟁의 불을 붙였다.
    -   하지만, 현대로  오면서 goto 문이 점점 제거되었고 마침내 데이크스트라가 승리하였음을 알 수 있었다.

>   현대의 우리 모두는 구조적 프로그래머이다. 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.



## 기능적  분해

>   구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 분해 할 수 있게 되었고, 모듈을 기능적으로 분해할 수 있게 되었다.

즉, 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.



## 엄밀한 증명은 없었다.

프로그램 관점에서 엄밀한 증명은 끝내 이루어지지 않았지만, 과학적 방법이 있다.



## 과학이 구출하다.

과학은 서술된 내용이 사실임을 증명하는 방싱이 아니라, 서술이 틀렸음을 증명하는 방식으로 동작한다.

각고의 노력으로도 반례를 들 수 없다면, 그것을 참이라고 본다.



## 테스트 

>   프로그램이 잘못되었음을 테스트를 통해 증명할 수 있지만, 프로그램이 맞다고 증명할 수는 없다.

테스트에 충분한 노력을 들였다면, 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.

거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게된다.



## 결론

-   구조적 프로그래밍이 오늘날까지 가치 있는 이유는 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.
    -   또한, 아키텍쳐 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도하다.

-   소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야한다.