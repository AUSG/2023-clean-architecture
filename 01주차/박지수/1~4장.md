# 1부 — 소개

## 1장) 설계와 아키텍처

### 설계 vs 아키텍처

- 설계: 저수준의 구조, 결정사항을 의미
- 아키텍처: 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킴

→ 하지만 저수준의 세부사항과 고수준의 구조는 소프트웨어 전체의 구성 요소, 경계가 불분명하다.
고수준에서 저수준으로 향하는 의사결정의 연속성만 존재

### 빨리 가는 유일한 방법은 제대로 가는 것이다.

- `시장에 출시가 먼저, 코드는 나중에 정리 한다.` 고 생각한다면, 불가능에 가깝다. → 시장의 압박은 **절대!** 수그러들지 않는다.
- 경영자에게도 알려줘야한다. 미래의 생산성을 지키고, 빨리 가기 위해서는 제대로 가야한다.
- 기능만 계속 추가하다보면 생산성을 0에 수렴한다.
    - 이쯤 되면 개발자는 `새로 만드는 것이 빠를지도?` 라는 생각을 하게 된다.
    - 하지만 마인드 개선이 없다면, 똑같이 엉망이 될 것이다.

### 개발 조직이 할 수 있는 최고의 선택지

- 소프트웨어 아키텍처의 품질을 심각하게 고민한다.
    - 그 전에 좋은 소프트웨어/아키텍처가 무엇인지 이해 한다.


## 2장) 두 가지 가치에 대한 이야기

### 행위, 아키텍처

- 모든 소프트웨어 시스템은 이해관계자에게 행위/구조 두 가지 가치를 제공
- 행위
    - 기계가 수익을 창출하거나 비용을 절약하도록 만든다. 즉, 기능 명세서/요구사항 문서를 구체화 하도록 돕고 문제를 해결한다.
- 아키텍처
    - 우리가 만드는 것은 **소프트**웨어다. → 변경하기 쉬워야 하고 변경사항을 적용하는 어려움은 범위에 비례하며, 형태와는 관련이 없어야 한다.
    - 아키텍터는 형태에 독립적이어야한다. → 기능을 구조에 맞추는 것은 어렵다. 기능에 맞는 구조를 찾아야 한다.

### 더 높은 가치 (행위, 아키텍처)

동작하지만 수정이 아예 불가능한 소프트웨어 VS 동작하지 않지만 쉽게 변경 가능한 소프트웨어

- 동작 여부가 미래의 유연성보다 더 중요하다. 하지만, 변경이 불가능한 상태에 처할 때 까지 방치해서도 안된다.

### 우선순위 (아이젠하워 매트릭스)

1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지 않은
4. 긴급하지도 중요하지도 않은

우리는 가끔 중요한 일을 방치하고 긴급한 일 먼저 하려고 한다. 중요한 일을 먼저 하자고 설득하는 것도 개발팀의 책임이다.

### 아키텍처를 위해 투쟁하라

- 회사에서 각 팀팀은 팀이 가장 중요하다고 스스로 믿는 가치를 위해 투쟁한다.
- 개발팀도 좋은 소프트웨어/아키텍처를 위해 싸우고 투쟁해야 한다. ㅎㅎㅎ

# 2부 — 벽돌부터 시작하기

## 3장) 패러다임 개요

### 구조적 프로그래밍

- 무분별한 점프(goto)는 해로움 → `if/then/else` `do/while/until` 로 대체
- 구조적 프로그래밍은 제어흐름의 직접전인 전환에 대한 규칙을 부과 ( == 직접적인 전환 막기 )

### 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과

### 함수형 프로그래밍

- 불변을 통해, 심볼의 값이 변경되지 않는 개념 기반의 람다 계산법 사용
    - 굉장히 까다로운 조건 아래에서는 변수 값 변경 가능
- 함수형 프로그래밍은 할당문에 대해 규칙을 부과

### 결론

- 아키텍처와 패러다임은 모두 관계가 있다.
    - 아키텍처의 경계를 넘나들기 위한 매커니즘으로 다형성을 이용
    - 데이터의 위치와 접근 방법에 대한 규칙을 부과하기 위해 함수형 프로그래밍 사용
    - 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용
- 패러다임과 아키텍처의 3가지 관심사 (함수, 컴포넌트 분리, 데이터 관리) 의 연관 관계를 주목하자.

## 4장) 구조적 프로그래밍

### 증명

- 데이크스트라가 생각하기에 모든 프로그래밍은 설령 단순할 지라도 인간의 두뇌로 감당하기엔 너무 많은 세부사항을 담고 있었음
    - 수학적 원리인 증명을 통해 해결하려고 하였다.
- 유클리드 계층 구조 (공리, 정리, 따름정리, 보조정리) 를 만들고자 하였음
- 프로그래머는 입증된 구조를 이용하고, 구조를 결합 시켜서 사용한다. → 코드가 올바르다는 사실을 스스로 증명하게 되는 것

> 프로그램의 세 가지 구조: `순차`, `분기`, `반복`
> 

### 기능적 분해

- 구조적 프로그래밍을 통해, 큰 기능을 작은 기능들로 분리하고, 저수준의 함수들로 분해할 수 있게 되었음
- 대규모 시스템 → 모듈/컴포넌트로 분리 → 입증 가능한 아주 작은 기능으로 세분화

### 엄밀한 증명은 없었다.

- 계층 구조는 만들어지지 않았다.
    - 대부분의 프로그래머는 세세한 기능 하나하나 엄밀히 증명하여 이득을 볼 것이라 생각하지 않음
- 과학적인 방법으로 접근
    - 반증 가능성에 의해 주도되는 과학을 사용
    - 증명 가능한 서술이 거짓임을 입증하는 원리 → 즉, 반례를 찾기 전까지는 목표에 부합할 만큼 참이라고 여긴다.

### 테스트

- 테스트를 통과한다 **≠** 테스트는 버그가 없다
- 테스트를 통해 프로그램이 잘못되었음을 증명 가능하지만, 맞다고 증명할 수는 없다.
- 테스트에 충분한 노력을 들였다면, 목표에 부합할 만큼은 충분히 참이라고 여길 만하다.

### 결론

- 우리는 과학과 같이 반증 가능성에 의해 주도되는 소프트웨어를 만들고 있다.
- 따라서 모듈/컴포넌트/서비스를 쉽게 반증 가능하도록 해야한다. 그리고 반증 가능한 기능으로 큰 기능을 분해해야한다.
