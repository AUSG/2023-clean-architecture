## 4장 구조적 프로그래밍

### 증명

데이크스트라가 생각하기에 모든 프로그래밍은 설령 단순할 지라도 인간의 두뇌로 감당하기엔 너무 많은 세부사항을 담고 있었음

→ 증명이라는 수학적 원리를 적용해 이 문제를 해결하고자 했다

→ 공리, 정리, 따름 정리, 보조 정리로 구성되는 유클리드 계층 구조를 만들고자 함 

프로그래머는 임증된 구조를 이용하고, 구조를 코드와 결합시켜 코드가 올바르다는 사실을 스스로 증명

모든 프로그램은 순차, 분기, 반복 세 가지 구조만으로 표현 가능하다

- 순차 ) 단순 열거법을 통해 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적
- 분기 ) 열거법을 재적용, 분기를 통한 각 경로를 열거했고, 두 경로가 수학적으로 적절한 결과를 만들어낸다면 증명은 신뢰할 수 있게 됨
- 반복 ) 귀납법을 이용. N의 경우가 올바르다고 가정할 때, N + 1의 경우도 올바름을 증명하며 열거법을 사용

### 해로운 성명서

데이크스트라 → goto문의 해로움을 통해 세 가지 제어구조에 대한 자신의 이ㅡ력을 피력 

데이크스트라의 승리, 현재 우리는 모두 구조적 프로그래머이며 제어 흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않음 

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됨 → 모듈을 기능적으로 분해할 수 있음
- 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있고, 이들 각 기능들은 다시 저수준의 함수들로 분해할 수 있음 ) 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용해 표현할 수 있다.

### 엄밀한 증명은 없었다

그러나 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않음. 그리고 세세한 기능 하나하나를 엄밀히 증명하는 고된 작업을 하는 프로그래머는 거의 없음

→ 그러나 입증 전략이 수학적인 유클리드 방식이 전부는 아님, 상당히 성공한 또 다른 전략은 과학적 방법

### 과학이 구출하다

과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작. 각고의 노력으로도 반례를 들 수 없는 서술이 있다면 목표에 부합할 만큼은 참이라고 봄

즉, 수학은 증명가능한 서술이 참 / 과학은 증명 가능한 서술이 거짓임을 입증하는 원리

### 테스트

데이크스트라 “테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다”

소프트웨어 개발이 수학적인 구조를 다루듯이 보여도, 소프트웨어 개발은 수학적 시도보다는 과학과 같다. 

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그리고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다 → 거짓임을 증명하려는 테스트가 실패하면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 됨

### 결론

구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 이 능력 때문임. 가장 작은 기능ㅇ에서부터 가장 큰 컴포넌트까지 모든 수준의 소프트웨어는 과학과 같고 반증 가능성에 의해 주도된다. 따라서 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능핟록 분주히 노력해야 한다