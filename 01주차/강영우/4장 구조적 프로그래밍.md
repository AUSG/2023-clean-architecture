# 4장.  구조적 프로그래밍

데이크스트라는 원시적인 환경에서 위대한 발견을 해냈다.

# 증명

---

데이크스트라가 인식한 문제는 프로그래밍은 어렵고 프로그래머는 프로그래밍을 잘 하지 못한다는 사실이었다. 이를 해결하기 위해 증명이라는 수학적 원리(유클리드 계층구조)를 이용해 이 문제를 해결하고자 했다. 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.

goto문이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 된다는 것을 발견하고 분할정복 접근법을 사용할 수 없게 된다.

goto문의 장점인 if/then/else와 do/while 같은 분기와 반복이라는 단순한 제어구조를 발견했다. 이를 통해 증명 가능한 단위로 모듈을 재귀적으로 세분화하는 것이 가능하다는 것을 생각해냈다. 이는 순차실행과 결합할 때 굉장해진다. 뵘과 야코피니는 모든 프로그램을 순차, 분기, 반복으로 표현할 수 있다는 것을 증명했다.

데이크스트라는 단순한 열거법을 이용해 순차 구문(sequential statement)이 올바름을 입증할 수 있음을 보여줬다. 분기(selection)의 경우 열거법을 재적용하는 방식으로 분기를 통한 각 경로를 열거했다. 반복(iteration)을 증명하기 위해 귀납법을 사용했다.

# 해로운 성명서

---

데이크스트라는 “goto문의 해로움”을 신문기사에 실었고 10년만에 입증되었다. 현재의 우리 모두는 구조적 프로그래머이고, 선택의 여지가 없다. 자바의 경우 goto문과 유사한 경우를 가져가지만 목적지 범위를 현재 함수 안으로 한정시키는 편이다.

# 기능적 분해

---

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다. 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 이를 또 다시 저수준의 함수들로 분해할 수 있고 이렇게 계속 분해할 수 있다.

이를 토대로 구조적 분석이나 구조적 설계같은 기법은 인기를 끌었고, 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있었다.

# 엄밀한 증명은 없었다

---

하지만 증명은 이루어지지 않았다. 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다. 하지만 과학적 방법(scientific method)이라는 전략을 사용한다.

# 과학이 구출하다

---

과학은 근본적으로 수학과는 다른데, 과학 이론과 법칙은 그 올바름을 절대 증명할 수 없기 때문이다. 과학적 방법은 반증은 가능하지만 증명은 불가능하다.

과학은 서술된 내용이 사실임을 입증하는 것이 아닌 서술이 틀렸음을 증명하는 방식으로 동작한다. 억지로 까내려고해도 반례를 들 수 없다면 참으로 취급한다.

# 테스트

---

프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만 프로그램이 맞다고 증명할 수는 없다. 소프트웨어는 이를 통해 수학이 아닌 과학에 가깝다.

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

# 결론

---

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 이런 능력 때문이다. 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야한다.