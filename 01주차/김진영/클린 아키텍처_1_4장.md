1. 소개

   1. 설계와 아키텍처란?
      - 목표는?
        - `소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.`
      - 사례 연구
        - 설계가 잘못되면 제품의 코드라인 수와 직원 수가 많아질 수록 생산성이 떨어질 수 있다.
      - 결론
        - SW 아키를 심각히 고려해 비용 최소화 생산성 최대화 해야한다.
   2. 두 가지 가치에 대한 이야기
      - 행위
        - SW가 특정 기능
      - 아키텍처
        - SW의 특정 기능들이 구성 방식
      - 더 높은 가치
        - 행위보다 아키가 더 중요함.
      - 아이젠하워 매트릭스
        - 왜냐하면 아이젠하워 매트릭스에 따르면 `2. 중요하지만 긴급하지 않음`이 `3. 긴급하지만 중요하지 않음`보다 위에 있음으로 아키텍처가 행위보다 중요하기 때문이다.
      - 아키텍처를 위해 투쟁하라
        - PM은 일정관리 등 자신의 책임, 마케터는 유저유입 등 각자의 책무를 위해 투쟁함으로 프로그래머인 너 또한 더 높은 가치인 아키를 위해 투쟁해야함.

2. 벽돌부터 시작하기: 프로그래밍 패러다임

   1. 패러다임 개요

      - 구조적 프로그래밍
        - `구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.`

      - 객체 지향 프로그래밍
        - `객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.`

      - 함수형 프로그래밍
        - `함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.`

      - 생각할거리
        - 패러다임은 기본적으로 추가가 아니라 제한하는 것
          - 구조적 => goto문
          - 객체 지향 => 함수 포인터
          - 함수형 => 할당문
        - 패러다임은 위 3개가 전부이다.
        - 기본적으로 1950 ~ 1960연대와 지금과 전혀 다를게 없다.

      - 결론
        - 세 가지 큰 관심사 
          1. 함수
          2. 컴포넌트 분리
          3. 데이터 관리
        - 위 관심사들로 부터 패러다임과 아키텍처는 밀접한 연관이 있다.

   2. 구조적 프로그램

      - 증명
        - 순차, 분기, 반복만으로 프로그래밍의 흐름제어를 하면 모듈화가 가능하다.
        - goto의 하위 집합 순차, 분기, 반복
        - goto문과 순차, 분기, 반복의 expression power가 같다.

      - 해로운 성명서
        - CACM에 데이크스트라가 goto문의 부정성에 대한 논문을 기고했다가 이에 대한 논쟁이 10년간 이어짐.
        - 결국 goto문은 역사의 뒤안길로… (~~RISC V에서도 빼달란 말이야~~)

      - 기능적 분해
        - goto문이 아닌 순차, 분기, 반복의 제한적 흐름제어자로의 한정을 통해 저수준 모듈로의 분리가 가능해짐.
        - 때문에 divide and conquire로 모듈, 컴포넌트 세분화 가능해지니까 programming language도 유클리드 계층구조를 구축함으로서 수학과 같이 논리적 엄밀성을 가질 수 있을 것으로 기대했다.

      - 엄밀한 증명은 없었다.
        - 하지만 이러한 논리 토대의 language의 expression power가 turing complete 하다는 증명은 여전히 해내지 못하였다. (난제 중 하나로 남아 있음.)

      - 과학이 구출하다
        - `수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다. 반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.`

      - 테스트
        - 항상 참임을 논리학적으로 증명하진 못함.
        - 하지만 거짓임 또한 증명이 불가능 함으로 과학적 관점의 엄밀함은 갖추고 있다고 할 수 있다.
        - 때문에 프로그램을 구성하는 모듈, 컴포넌트들이 거짓임을 증명하려는 테스트에 대하여 거짓이라면 충분히 참이라 볼 수 있다.

      - 결론
        - 구조적 프로그래밍의 가치는 반증 가능한 단위로 나눌 수 있음에 있다.
        - 가장 작은 단위 => 가장 큰 컴포넌트까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 증명됨.
        - 때문에 SW 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증가능성을 유지하도록 만들기 위해 노력해야함.