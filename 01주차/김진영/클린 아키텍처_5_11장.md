5. 객체 지향 프로그래밍

   - 캡슐화?
     - 근대에 OO 언어는 C 언어에서 완벽한 캡슐화 제공하였던 것을 오히려 악화시킴.

   - 상속?
     - OO 언어 이전에도 상속과 같은 기능을 구현할 수 있었고, OO 언어는 이를 편리하게 해줄 뿐임.

   - 다형성?
     - 기존 언어의 경우 포인터를 활용하여 다형성을 구현해야 해서 위험이 컸음.
     - 하지만 OO 언어는 실수할 위험 없이 다형성을 지원하여 제어흐름을 간접적으로 전환할 수 있게 됨.
     - 다형성이 가진 힘
       - OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 됨.
     - 의존성 역전
       - 기존에는 반드시 의존성의 방향이 제어흐름을 따랐음.
       - 하지만 다형성(인터페이스)을 통해 소스 코드 의존성을 원하는 방향으로 설정 가능.
       - 때문에 배포 독립성, 개발 독립성을 가질 수 있게 됨.

   - 결론
     - OO란 다형성을 이용해 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력.
     - OO를 통해 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준 정책 모듈을 저수준의 세부사항 포함하는 모듈에 대해 독립성을 보장받을 수 있음.

6. 함수형 프로그래밍

   - 정수를 제곱하기
     - 함수형 언어에서 변수는 불변.

   - 불변성과 아키텍처
     - 동시성 애플리케이션에서 모든 문제는 가변 변수에서 온다.

   - 가변성의 분리
     - 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리.
     - 가능한 많은 처리를 불변 컴포넌트로 옮기고, 가변 컴포넌트에서 가능 한 많은 코드 빼내자.

   - 이벤트 소싱
     - 모든 트랜잭션을 저장하고 처리하는 방식으로 불변적인 완전한 함수형을 만들 수 있다.

   - 결론
     - 구조적 프로그래밍: 제어흐름 직접적 전환
     - 객체 지향 프로그래밍: 제어흐름 간접적인 전환
     - 함수형 프로그래밍: 변수 할당에 부과되는 규율
     - 소프트웨어의 핵심은 1946년 엘런 튜링 이후로 변경된 것이 없음
     - 소프트웨어는 순차, 분기, 반복, 참조로 구성되고 그 이상, 이하도 아니다.

7. SRP: 단일 책임 원칙

   - 징후 1: 우발적 중복
     - 서로 다른 액터(이해관계집단)가 의존하는 코드를 서로 분리
   - 징후 2: 병합
     - 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우
   - 해결책
     - 메서드를 각기 다른 클래스로 이동하여 해소
   - 결론
     - SRP는 메서드와 클래스 수준의 원칙.
     - 컴포넌트, 아키텍쳐 수준에서 다른 형태로 다시 등장. 

8. OCP: 개방-폐쇄 원칙

   - > 소프트웨어 개체는 확장에 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

   - 사고 실험
     - 컴포넌트 계층구조의 조직화를 통해 저수준 컴포넌트의 변경으로 부터 고수준 컴포넌트를 보호할 수 있다.
   - 방향성 제어
     - 인터페이스를 컴포넌트 중간에 줌으로 의존성을 역전시킬 수 있다.
   - 정보 은닉
     - 인터페이스를 통해 추이 종속성을 제거함으로서 인터페이스 양쪽의 컴포넌트의 내부 은닉을 통해 상호 변경을 통한 영향을 제거할 수 있다.
   - 결론
     - 저수준 컴포넌트의 변경으로 부터 고수준 컴포넌트를 보호함으로서 시스템의 영향 범위를 최소활 수 있다.

9. LSP: 리스코프 치환 원칙

   - 상속을 사용하도록 가이드하기
     - 하위 타입을 상위 타입으로 치환 가능
   - 정사각형/직사각형 문제
     - LSP 위반의 경우 타입 치환이 불가능 하다.
   - LSP와 아키텍처
     - LSP는 상속의 가이드 뿐만 아니라 아키텍처 설계 원칙으로 변모해 왔다.
   - LSP 위배 사례
     - 아키텍쳐 또한 LSP 위배 시 많은 문제를 유발함.
   - 결론
     - 치환 가능성 위배 시에 아키텍처가 오염됨.

10. ISP: 인터페이스 분리 원칙

    - ISP와 언어
      - 동적 프로그래밍 언어는 정적 언어와 다르게 import 선언문이 없어 소스 코드 의존성이 없음
      - 때문에 ISP는 언어와 관련된 문제이기도 함.
    - ISP와 아키텍처
      - 인터페이스 분리가 되어 있지 않으면 필요 이상 많은 것을 포함한 모듈에 의존하게 되어 의존성이 커짐.
    - 결론
      - 불필요한 것에 의존하면 예상치 못한 문제에 빠질 수 있다.

11. DIP: 의존성 역전 원칙

    - > 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

    - 안정된 추상화
      - 인터페이스는 구현체보다 변동성이 낮다. 
      - 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍쳐라는 뜻이다.
        - 변동성이 큰 구체 클래스를 참조하지 말라.
        - 변동성이 큰 구체 클래스로부터 파생하지 말라.
        - 구체 함수를 오버라이드 하지 말라.
        - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
    - 팩토리
      - 변동성이 큰 구체적인 객체는 추상 팩토리를 통해 주의하여 생성
    - 구체 컴포넌트 
      - DIP를 항상 만족할 수 없다.
      - DIP를 위배하는 구체 컴포넌트는 메인으로 모아서 사용. (최소의 사용범위)
    - 결론
      - DIP는 이후 계속 중요하게 언급될 것임.