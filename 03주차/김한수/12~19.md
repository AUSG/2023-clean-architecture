# 12~19

- [12~19](#1219)
- [12. 컴포넌트](#12-컴포넌트)
- [13. 컴포넌트 응집도](#13-컴포넌트-응집도)
  - [REP: 재사용/릴리스 등가 원칙](#rep-재사용릴리스-등가-원칙)
  - [CCP: 공통 폐쇄 원칙](#ccp-공통-폐쇄-원칙)
  - [CRP: 공통 재사용 원칙](#crp-공통-재사용-원칙)
  - [컴포넌트 응집도에 대한 균형 다이어그램](#컴포넌트-응집도에-대한-균형-다이어그램)
- [14. 컴포넌트 결합](#14-컴포넌트-결합)
  - [ADP: 의존성 비순환 원칙](#adp-의존성-비순환-원칙)
    - [주 단위 빌드(Weekly Build)](#주-단위-빌드weekly-build)
    - [순환 의존성 제거하기](#순환-의존성-제거하기)
    - [순환 끊기](#순환-끊기)
    - [ADP 요약](#adp-요약)
  - [SDP: 안정된 의존성 원칙](#sdp-안정된-의존성-원칙)
    - [안정성 측정하기](#안정성-측정하기)
  - [SAP: 안정된 추상화 원칙](#sap-안정된-추상화-원칙)
- [15. 아키텍처란?](#15-아키텍처란)
  - [유지보수](#유지보수)
  - [결론](#결론)
- [16. 독립성](#16-독립성)
  - [결론](#결론-1)
- [17. 경계: 선 긋기](#17-경계-선-긋기)
  - [결론](#결론-2)
- [18. 경계 해부학](#18-경계-해부학)
- [19. 정책과 수준](#19-정책과-수준)

# 12. 컴포넌트

- `컴포넌트 플러그인 아키텍처(component plugin archtecture)`의 탄생 이야기
- 오늘날 우리에게 .jar파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것은 너무나도 당연하고 자연스러운데
- 사실 여기까지 오는데 50년이 걸렸고 이 챕터에서는 이 이야기를 한다.
  - 초기에 함수 라이브러리를 직접 특정 메모리를 지정해서 사용하던 때부터
  - 지금의 단순히 라이브러리를 import하기만해도 메모리에 동적 로딩되는 시점까지

# 13. 컴포넌트 응집도

- 컴포넌트 응집도와 관련된 세 가지 원칙을 알아보자
  - `REP(Reuse/Release Equivalence Principle)` : 재사용/릴리스 등가 원칙
  - `CCP(Common Closure Principle)`: 공통 폐쇄 원칙
  - `CRP(Common Reuse Principle)`: 공통 재사용 원칙

## REP: 재사용/릴리스 등가 원칙

> **재사용 단위는 릴리스 단위와 같다.**
>
- 이 원칙은 소프트웨어 설계와 아키텍처 관점에서 보면
  - **단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.**
  - **즉. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야한다.**
- **REP가 지켜지지 않으면 무슨일 발생할까?**
  - **릴리스 번호가 없거나 등가 원칙을 지키지 않는다면,**
    해당 모듈을 사용하는 개발자는 모듈의 변경사항을 추적하지 못하고
    이는 곧 해당 모듈에 대한 신뢰를 잃게되고 결국 사용하지 못할 것이다.
- 무언가가 **‘이치에 맞다’** 라고 말하는 것은 그저 허공에 손을 흔들며 권위있는 척하는 것에 불과하지만
적어도 `REP` 원칙을 어기면 **‘이치에 맞지 않는’** 행위를 하는 것이니 주의하자

## CCP: 공통 폐쇄 원칙

> **동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶고
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라**
>
- 이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 격이다.
  - `CCP`도 SRP와 같은 맥락으로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다는 것을 뜻한다.
  - 그리고 동일한 유형의 변경에 대해서 하나의 컴포넌트 내에서 이루어지도록 **폐쇄**해야한다.
- **즉. 어떤 행위에 대해서 변경되는 범위를 좁은 범위로 제어할 수 있게 유지해야 하는 것을 의미한다.**

## CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
>
- `CRP`는 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
- **이 원칙은 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야한다고 말한다.**
- 즉. 강한 결합이 있는 경우가 아니면 동일한 컴포넌트에 위치시켜서는 안 된다는 것을 의미한다.
  - 이 원칙을 지키지 않으면 불필요한 컴포넌트를 재배포하는 상황에 놓이게 될 것이다.

## 컴포넌트 응집도에 대한 균형 다이어그램

사실 위 응집도에 관한 세 원칙은 서로 상충된다.

- `REP`, `CCP`는 포함(inclusive)원칙이며, 컴포넌트를 더욱 크게 만든다.
- `CPR`는 배제(exclusive)원칙이며, 컴포넌트를 더욱 작게 만든다.
- 다음 균형 다이어그램으로 각 원칙이 어떻게 상호작용하는지 이해해보자
  - 결국 트레이드오프일텐데 프로젝트의 진행상황에 따라
  - 초기에는 개발 가능성이 재사용성보다 중요하여 CCP가 REP보다 훨씬 중요하고
  - 프로젝트가 성숙했을 때 점차 삼각형의 왼쪽으로 이동한다.
  - 결국 아키텍처도 요구사항에 맞게 점진적으로 진화해야한다는 것을 의미한다.

    ![1.png](https://user-images.githubusercontent.com/72328687/222934513-155bc5ad-ff6a-4b32-888c-adc67ecfd880.png)

# 14. 컴포넌트 결합

이제 컴포넌트 사이의 관계를 설명하는 3가지 원칙을 알아보자

- `ADP(Acyclic Dependencies Principle)` : 의존성 비순환 원칙
- `SDP(Stable Dependencies Principle)` : 안정된 의존성 원칙
- `SAP(Stable Abstractions Principle)` : 안정된 추상화 원칙

## ADP: 의존성 비순환 원칙

> **컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.**
>
- 여러 명의 개발자가 같은 소스 파일을 수정하면 항상 사이드 이펙트가 발생할 가능성이 있고,
따라서 누군가가 마지막으로 수정한 변경사항으로 인해 내가 개발했던 코드가 망가질 수 있다.
- 이 문제의 해결책으로는 다음 두 가지 방법이 발전되어 왔다
  - `주 단위 빌드`
  - `ADP(의존성 비순환 원칙)`

### 주 단위 빌드(Weekly Build)

- `주 단위 빌드`는 단순하게 팀 내에서 배포 사이클을 지정하고 배포 일정에 맞추어 코드에 문제가 없는지 확인하는 통합 과정을 거치는 것이다.
  - 이는 안정성을 챙겨갈 수 있지만 작업량이 많을 수록 고통스러운 작업이 되어간다.
  - **또한 빠른 피드백을 잃게되니 비즈니스적으로 치명적일 수 있다.**

### 순환 의존성 제거하기

- 의존성에 의한 사이드 이펙트를 피하기 위해서는
**개발 환경을 릴리스 가능한 컴포넌트로 분리하고 각 팀별로 책임을 나눈 뒤 각 릴리스에 버전을 부여한다.**
- 그리고 그 릴리스 버전을 기준으로 의존하여 적어도 그 버전에서는 사이드 이펙트를 피할 수 있다.
- 그런데 이게 성공적으로 동작하기 위해서는 `순환 의존성`이 없어야만 한다.
  - 순환 의존성이 생기면 사이드 이펙트가 생기는 숙취 증후군을 피할 수 없다.
  - 그리고 빌드 단계에서 생기는 단위 테스트 유지보수 등 복잡도가 높아진다.
- 순환 의존성이 없으려면 결국 컴포넌트의 의존 관계가
단방향을 띄는 `비순환 방향 그래프`(DAG: Directed Acyclic Graph)가 되어야한다.

### 순환 끊기

순환을 끓어내는 주요 매커니즘 두 가지에 대해서 알아보자

- `DIP`(의존성 역전 원칙)을 적용한다.
  - 전형적인 interface와 구현체 조합으로 해결 의존성을 제어
- 순환 의존성이 생기는 컴포넌트 사이에서 공통으로 의존하는 새로운 컴포넌트를 만든다.
  - `A` → `B` → `A` 의 구조라면 `A` → `C`, `B` → `C` 로 풀어낸다.
  - 단순히 공통 코드를 다른 컴포넌트로 빼는 방식
  - 이는 실제로 애플리케이션이 성장함에 따라 컴포넌트 구조가 변경되고 분리될 수 있는 것을 의미하는데
     `흐트러짐(Jitters)` 이라고도 표현한다.
  - 때로는 의존성 구조가 더 커질 수 있는 것을 의미하지 주의하자

### ADP 요약

- 결국 컴포넌트는 시스템에서 가장 먼제 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.
- **아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 상당히 큰 실패를 맛볼 수 있으니 주의하자**
- 생각보다 컴포넌트를 새로 만들 때 순환 의존성 문제를 자주 만나게 될 수 있으니
**시스템에 대해서 잘 이해하고** `결정은 최대한 늦게`

## SDP: 안정된 의존성 원칙

> **안정성의 방향으로(더 안정된 쪽에) 의존하라**
>

설계는 결코 정적일 수 없다. 그래서 변동성을 쉽게 제어할 수 있는 방향성을 가지고 설계하는 것이 좋다.

- 일부 컴포넌트는 변동성을 지니도록 설계되는데, 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어선 안된다.
- **누군가 해당 컴포넌트에 의존하는 순간 변동성이 큰 컴포넌트도 결국 변경하기 어려워지고
어느순간 해당 컴포넌트를 수정하는 것이 상당히 도전적인 일이 될 수 있다.**

### 안정성 측정하기

컴포넌트의 안정성 측정 방법은 단순하다.

- 해당 컴포넌트를 의존하는 다른 컴포넌트가 많을 수록 안정성이 높고
- 해당 컴포넌트가 다른 컴포넌트가 많이 의존할 수록 안정성이 낮다.

![2.png](https://user-images.githubusercontent.com/72328687/222934518-3002f06c-c060-4cb5-a71f-5e098aef8810.png)

- 위 X 컴포넌트를 의존하는 컴포넌트가 3개이고, X가 의존하는 컴포넌트는 없다.
  - 따라서 X가 변경되지 말아야하는 요인이 3개이므로 **안정성이 높고**
  - X가 변경되도록 하는 요인이 없으므로 X는 **독립적이다.**

![3.png](https://user-images.githubusercontent.com/72328687/222934519-2408a2d3-69cc-4d1b-bab8-981f4faa6b27.png)

- 그리고 위 Y 컴포넌트를 의존하는 컴포넌트는 없고, Y가 의존하는 컴포넌트는 3개인 경우
  - 어떤 컴포넌트도 Y에 의존하지 않으므로 변경에 대해 **책임이 없고**
  - 3개의 컴포넌트에 변경될 가능성이 높다. 따라서 **의존적이다**

## SAP: 안정된 추상화 원칙

> **컴포넌트는 안정된 정도만큼만 추상화되어야 한다.**
>
- 안정된 추상화 원칙은 `안정성`과 `추상화` 정도 사이의 관계를 정의한다.
  - 한편으로는 **안정된 컴포넌트는 추상 컴포넌트여야 하고, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.**
  - 다른 한편으로는 **불안정한 컴포넌트는 반드시 구체 컴포넌트여야한다.**

# 15. 아키텍처란?

아키텍처의 주된 목적은 소프트웨어 시스템의 생명주기를 지원하는 것이다.

- 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다.
- 즉. `시스템의 수명과 관련된 비용 최소화`, `프로그래머의 생산성 최대화`가 궁극적 목표이다.

## 유지보수

유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.

- `탐사(spelunking)`
  - 유지보수 중 가장 큰 비용이 드는 작업 범위 파악과 최적의 선택을 위한 고민 과정이다.
    - 변경사항을 반영할 때 의도되지 않은 결함이 발생할 가능성이 항상 존재하고 이 위험부담 비용도 포함된다
  - 아키텍처를 잘 만들어 컴포넌트를 분리하고 안정된 인터페이스를 두어 서로 격리한다면
    탐사에 지름길과 사이드 이펙트를 방지할 수 있어 이 과정에 큰 도움을 준다

## 결론

**좋은 아키텍트는 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.**

- 변경에 유연하도록 세부사항과 정책의 분리 (추상화)

# 16. 독립성

좋은 아키텍처는 다음을 지원해야한다

- `시스템의 유스케이스`
  - 궁극적으로 아키텍처는 장바구니 추가 등 비즈니스에 필요한 행위들 즉. 유스케이스를 지원해야한다.
  - **좋은 아키텍처는 행위를 명확히하고 외부로 드러내며, 이를 통해 시스템이 가진 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.**
- `시스템의 운영`
  - **운영 관점에서 서비스의 성장에 따라 트래픽이 늘어날 때 시스템이 이를 유연하게 대응할 수 있어야한다.**
  - 각 컴포넌트를 적절히 격리하고 각 컴포넌트 간의 통신 방식을 특정 형태로 제한하지 않는다면
    시간이 지나 운영에 필요한 요구사항이 바뀌더라도 이를 적절하게 전환하는 것이 훨씬 수월할 것이다.
- `시스템의 개발`
  - 아키텍처는 개발환경을 지원하는데도 핵심적인 역할을 수행한다.
  - **조직이 커지고 팀이 분리될 수록 각 팀들이 개발하는 동안 서로 방해받지 않도록 해야한다.**
  - 이러한 아키텍처는 컴포넌트 단위로 시스템을 분할하고 적절하게 독립적으로 개발할 수 있도록 해야할 것이다.
- `시스템의 배포`
  - 아키텍처는 배포 용이성을 결정하는 중요한 역할을 하고 `즉각적인 배포`를 목표로 해야한다.

## 결론

- **선택사항은 항상 열어두어야하고 결정은 최대한 미루는 것이 좋다**
  - 우리는 모든 사항을 예측할 수 없고 최대한 늦게 결정하는 것이 시스템과 정신 건강에 이롭다.
- **컴포넌트를 적절하게 분리하고 격리시키고 쉽게 교체할 수 있도록 하자**
  - 이는 배포, 개발, 유스케이스를 유연하게 조절할 수 있도록 도와줄 것이다.
- **항상 주어진 상황을 기반으로 트레이드오프를 고려하자**
  - 시스템은 초기부터 완벽한 구조를 가져갈 수 없다. 시스템이 성숙해갈수록 최적인 선택은 달라질 수 있으니 이를 주의하자

# 17. 경계: 선 긋기

소프트웨어 아키텍처는 선을 긋는 기술이며, 앞으로 이 책에서는 이러한 선을 `경계`라고 칭할 것이다.

- `경계`는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.
- 이들 경계 중 일부는 프로젝트 수명 중 아주 초기에, 심지어 코드가 전혀 작성되기도 전에 만들어지고, 어떤 경계는 매우 나중에 만들어진다.
  - **초기에 만들어지는 경계는 가능한 한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하게 만들려는 목적으로 쓰인다.**

## 결론

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야한다

- 일부 컴포넌트는 핵심 업무 규칙에 해당하고
핵심 업무와는 직접적인 연관은 없지만 필수 기능을 포함하는 나머지 컴포넌트는 플러그인으로 구성하고
- 그 이후 컴포넌트 사이의 방향이 특정 방향으로만 흐르도록,
즉. 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치해야한다.
- 항상 의존성의 방향은 저수준 세부사항에서 고수준의 추상화를 향하도록 하기!

# 18. 경계 해부학

컴포넌트는 경계를 기준으로 분리되고 이 경계는 다양한 형태로 나타난다

- 한 리포지토리에 코드가 모두 존재하는 단일체
- 배포형 컴포넌트 = jar 같은 동적 링크 라이브러리
- 서비스 등등..

**가장 중요한 건 저수준 서비스는 반드시 고수준 서비스에 플러그인 되는 형태로 설계하는 것이라는 것을 잊지 말자**

# 19. 정책과 수준

소프트웨어 시스템이란 정책을 기술한 것이다.

- 소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다.
- 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며 동일한 컴포넌트에 속해야 한다.
- 반대로 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치해야하며, 반드시 다른 컴포넌트로 분리해야한다.
