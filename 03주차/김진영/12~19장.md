# 클린아키텍처

- 12. 컴포넌트
    
    컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.
    
    - 컴포넌트의 간략한 역사
      
        통짜 소스코드 파일에서 빌드시간이 길어짐에 따라 이를 해결하기 위해 라이브러리 코드들을 분리하였다. 하지만 프로그램과 라이브러리가 사용하는 메모리가 늘어날수록 아래와 같은 단편화가 계속될 수 밖에 없다.
        
        ![Untitled](%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20cb40b733f284406198df18fd51d33c82/Untitled.png)
        
    - 재배치성
      
        지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방식으로 해결하였다. 이는 이후 링킹 로더로 발전하였다.
        
    - 링커
      
        링킹 로더의 속도가 점점 느려지면서 링킹 로더가 링커와 로더로 분리되었다. 이후 하드웨어의 발전으로 로드와 링크를 동시에 할 수 있게되었다. 이는 컴포넌트 플로그인 아키텍처를 탄생시켰다.
        
    - 결론
      
        런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다. 이제는 쉽게 컴포넌트 플러그인 아키텍처를 적용할 수 있게 되었다.
  
- 13. 컴포넌트 응집도
    - REP: 재사용/릴리스 등가 원칙
      
        재사용 단위는 릴리스 단위와 같다.
        
    - CCP: 공통 폐쇄 원칙
      
        동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
        
    - CRP: 공통 재사용 원칙
      
        컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
        
    - 컴포넌트응집도에 대한 균형 다이어그램
        - 프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변해간다
            - 일반적으로 프로젝트 초기에는 CCP가 REP보다 중요하지만, 고도화 됨에 따라 REP가 중요해진다.
        
        ![Untitled](%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%20cb40b733f284406198df18fd51d33c82/Untitled%201.png)
        
    - 결론
        - 애플리케이션의 요구에 맞게 균형을 잡는 일이 중요하다.
        - 시간이 흐름에 따라 프로젝트 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.
- 14. 컴포넌트 결합
    - ADP: 의존성 비순환 원칙
      
        컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
        
    - 하향식(top-down) 설계
        - 컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.
        - 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 것과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
    - SDP: 안정된 의존성 원칙
        - 안정성의 방향으로 (더 안정된 쪽에) 의존하라.
    - SAP: 안정된 추상화 원칙
        - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
    - 결론
      
        의존성 관리 지표로 설계의 적절한 의존성과 추상화 정도를 측정해볼 수 있다.
  
- 15. 아키텍쳐
    
    아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성을 최대화하는 데 있다. 
    
    - 개발
        - 시스템 아키텍처는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.
    - 배포
        - 소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.
    - 운영
        - 하드웨어는 값 싸고 인력은 비싸다는 말이 뜻하는 바는 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 덜 든다.
        - 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.
    - 유지보수
        - 유지보수는 모든 측면에서 봤을 때 SW 시스템에서 비용이 가장 많이 든다.
        - 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.
    - 선택사항 열어 두기
      
        좋은 아키텍트는 결정되지 않는 사항의 수를 최대화 한다.
        
    - 장치 독립성
        - 천공 카드 처리 로직이 비지니스 로직에 강결합되어 있어 자기테이프로 마이그레이션이 어려웠던 사례를 이야기하며 OCP가 탄생했다고 설명한다.
    - 광고 우편
      
        세부사항인 장치를 정책으로 부터 분리하며 얻은 이점을 자신의 광고우편 인쇄 사례로 설명하였다.
        
    - 물리적 주소 할당
      
        디스크의 물리주소 할당 예시를 들며 고수준의 정책이 세부사항인 디스크의 물리적 구조 등으로 부터 독립되는 것이 왜 중요한지 설명하고 있다.
        
    - 결론
        - 세부사항을 정책으로 부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리해야 한다.
        - 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계해야한다.
- 16. 독립성
    - 하위 목차
        - 유스케이스
        - 운영
        - 개발
        - 배포
        - 선택사항 열어놓기
        - 계층 결합 분리
        - 유스케이스 결합 분리
        - 결합 분리 모드
        - 개발 독립성
        - 배포 독립성
        - 중복
        - 결합 분리 모드(다시)
    - 결론
        - 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉽다.
        - 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.
- 17. 경계: 선 긋기
    - 하위 목차
        - 두 가지 슬픈 이야기
        - FitNesse
        - 어떻게 선을 그을까? 그리고 언제 그을까?
        - 입력과 출력은?
        - 플러그인 아키텍처
        - 플러그인에 대한 논의
    - 결론
      
        핵심 업무규칙을 제외한 컴포넌트들은 플러그인으로 저수준이 고수준을 의존하도록 구성하여야 한다.
  
- 18. 경계 해부학
    
    - 하위 목차
        - 경계 횡단하기
        - 두려운 단일체
        - 배포형 컴포넌트
        - 스레드
        - 로컬 프로세스
        - 서비스
    - 결론
      
        한 시스템 안에서도 로컬, 서비스, 모듈 등 다양한 유형의 경계가 공존한다.
    
- 19. 정책과 수준
    
    - 수준
        - 입력과 출력에서 멀수록 핵심 컴포넌트다.
    - 결론
        - 상동