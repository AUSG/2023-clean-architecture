# 12. 컴포넌트

>   컴포넌트는 배포 단위이다.



## 컴포넌트의 간략한 역사

-   소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어 했다.
-   프로그래머가 라이브러리 함수의 소스코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일 했다.
-   애플리케이션과 라이브러리가 계속 커지면서, 단편화가 발생하여 이 문제를 해결할 필요가 있었다.



## 재배치성

-   해결책은 재배치가 가능한 바이너리 였다.
    -   지능적인 로더를 사용해서 메모리에 재배치 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것.
    -   프로그램이 라이브러리 함수를 호출하면 라이브러리 함수 이름을 외부참조로 생성.
-   이렇게 링킹 로더가 탄생하였다.



## 링커

-   링킹 로더가 너무 느려, 로드와 링크를 분리.
    -   링커는 링크가 완료된 재배치 코드를 만들었고, 이를 통해 로딩을 빠르게 할 수 있었다.
-   하지만, 전체 모듈을 컴파일 하는 시간은 계속 커지게 되었음.
    -   but, 무어의 법칙에 따라 디스크의 속도가 매우 빨라져 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 사용할 수 있게 되었다.



## 결론

-   런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.





# 13. 컴포넌트 응집도

이 장에서 컴포넌트 응집도와 관련된 세가지 원칙을 논의한다.

-   REP : 재사용/릴리스 등가 원칙
-   CCP : 공통 폐쇄 원칙
-   CRP : 공통 재사용 원칙



## REP : 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)

>   재사용의 단위는 릴리스 단위와 같다.

-   단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 함을 뜻한다.

-   CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.



## CCP : 공통 폐쇄 원칙 (Common Closure Principle)

>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래슨느 다른 컴포넌트로 분리하라.

-   SRP 에서 단일 클래스는 변경의 이유가 여러개 있어서는 안된다고 말하듯, 공통 폐쇄 원칙(CCP)에서도 마찬가지로 단일 컴포넌트는 변경의이유가 여러개 있어서는 안된다고 말한다.
-   애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기 보다, 단일 컴포넌트에서 발생하는 편이 낫다.
    -   CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
    -   CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.



### SRP와의 유사성

>   동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.

-   CCP는 컴포넌트 수준의 SRP다.
    -   SRP에서 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다.
    -   CCP에서는 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다.



## CRP: 공통 재사용 원칙 (Common Reuse Principle)

>   컴포넌트 사용자들을 필요하지 않는것에 의존하게 강요하지 말라.

-   CRP에서는 같이 재사용 되는 경향이 있는 클래스와 모듈은 같은 컴포넌트에 포함해야 한다고 한다.

-   CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지 설명해 주며, 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.

-   따라서, 강하게 결합되지 않는 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.



### ISP와 관계

>   필요하지 않는 것에 의존하지 말라.

-   CRP는 인터페이스 분리원칙(ISP)의 포괄적인 버전이다.
    -   ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 한다.
    -   CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 한다.



## 컴포넌트 응집도에 대한 균형 다이어그램

>    응집도 세원칙은 서로 상충된다는 것을 눈치챘을 것이다.

-   REP와 CCP는 포함 원칙이다.
    -   즉 두원칙은 컴포넌트를 더욱 크게 만든다.
-   CRP는 배제 원칙이다.
    -   컴포넌트를 더욱 작게 만든다.



아키텍트는 여기에서 균형을 잘 잡아야한다.

-   REP와 CRP에 중점을 두면 사소한 변경시 너무 많은 컴포넌트에 영향을 미친다.
-   CCP와 REP에만 과도하게 집중하면 불필요한 릴리즈가 빈번해 진다.



## 결론

어느 클래스들을 묶어서 컴포넌트로 만들지 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다





# 14. 컴포넌트 결합



## ADP: 의존성 비순환 원칙

>   컴포넌트 의존성 그래프에 순환이 있어서는 안된다.



### 주단위 빌드

-   4일은 개발하고 금요일은 통합과 관련된 일을 한다.
-   프로젝트가 커질수록 통합하는 일은 커지고 오래걸리고, 어렵고, 팀끼리 빠른 피드백이 어렵게 된다.



### 순환 의존성 제거하기

-   개발환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것
    -   개발자는 자신만의 공간에서 컴포넌트를 지속 수정하고, 나머지 개발자는 릴리즈된 버전을 사용한다.
    -   새 컴포넌트가 릴리즈 되면 다른 팀에서는 새 버전또는 이전버전을 적용할지 결정할수 있다.
    -   특정 컴포넌트가 변경되더라도 다른팀에 즉각 영향을 주지 않는다.



### 순환이 컴포넌트 의존성 그래프에 미치는 영향

-   순환은 즉각적 문제를 일으킨다.
-   어떤순서로 빌드해야 올바를지 파악하기 힘들다. -> 순환이 생기면 올바른 순서 자체가 없을수 있다.



### 순환끊기

컴포넌트 사이 순환을 끊고 의존성을 다시 DAG로 복구하기는 언제든 가능하다.

1.   의존성 역전 원칙 (DIP)을 적용한다. 
2.   순환이 발생하는 컴포넌트가 모두 의존하는 새로운 컴포넌트를 만들어, 모두 의존하는 클래스를 새로운 컴포넌트로 이동시킨다.



### 흐트러짐

-   2번 해결책에서 요구사항 변경으로 컴포넌트 구조도 변경되었다.
-   실제 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.
    -   의존성 구조에 순환이 발생하는지 항상 관찰해야 한다.
    -   순환이 발생하면 어떤식으로든 끊어야 한다.



## 하향식 설계

>   컴포넌트 구조는 하향식으로 설계될 수 없다.

-   컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니다. 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

    

## SDP : 안정된 의존성 원칙

>   안정성의 방향으로(더 안정된 쪽에) 의존하라.

-   변동성을 지닌 컴포넌트는 언젠간 변경된다고 예상함.
-   따라서, 변경이 쉽지않은 컴포넌트가 변동성을 지닌 컴포넌트에 의존되면 안됨.



### 안정성

-   의존하는 컴포넌트가 많을 수록 안정적이다고 이야기하고, 반대인 경우 의존적이라고 말한다.
    -   의존하는 컴포넌트가 많을수록 변경되면 안되는 이유가 많아진다.



### 안정성 지표

-   불안정성 : I = Fan-out / (Fan-in + Fan-out) , I =1이면, 최고로 불안정한 컴포넌트, I = 0이면, 최고로 안정한 컴포넌트다.
    -   의존성 방향으로 갈수록 I지표 값이 감소해야 한다.
-   Fan-in: 안으로 들어오는 의존성. 
    -   이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
-   Fan-out : 바깥으로 나가는 의존성. 
    -   이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다.



### 모든 컴포넌트가 안정적이여야 하는 것은 아니다

-   모든 컴포넌트가 최고로 안정적이라면, 변경이 불가능하다
    -   불안정한 컴포넌트와, 안정적인 컴포넌트가 함께 존재해야한다.
-   안정적인 컴포넌트가 갑자기 다른 컴포넌트를 의존하게 되면 SDP를 위반한다.
    -   이를 위해 추상 컴포넌트를 하나 만들어 각 컴포넌트가 추상 컴포넌트를 의존하는 방식으로 해결할 수 있다.



### 추상 컴포넌트

-   오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식인 추상 컴포넌트는 상당히 안정적이다.

-   따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.



## SAP: 안정된 추상화 원칙

>   컴포넌트는 안정된 정도만큼만 추상화되어야 한다.



### 고수준 정책을 어디에 위치 시켜야 하는가?

-   고수준의 정책은 안정적인 컴포넌트에 위치해야한다.
    -   하지만, 이렇게 되면 수정이 어려워진다.
    -   OCP로 해결할 수 있다.
        -   어떤 클래스가 이 원칙을 준수하는가? 바로 추상 클래스이다.



### 안정된 추상화 원칙

-   안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.
-   불안정한 컴포넌트는 반드시 구체 컴포넌트여야한다고 말하는데, 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
-   SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다.
    -   실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하고, SDP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.
    -   따라서 의존성은 추상화의 방향으로 향하게 된다.



### 추상화 정도 측정하기

다음은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.

-   NC: 컴포넌트의 클래스 개수
-   Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
-   A: 추상화 정도.  A = Na / Nc
    -   A가 0이면 추상 클래스가 한개도 없고, 1이면 오로지 추상 클래스만 있음



### 주계열

-   최고로 안정적이며 추상화된 컴포넌트는 좌측 상단인 (0, 1)에 위치한다.
-   최고로 불안정하며 구체화된 컴포넌트는 우측 하단인 (1, 0)에 위치한다.

-   모든 컴포넌트가 이 두 지점에 위치하는 것은 아니다.
    -   고통의 구역과 쓸모 없는 구역을 보며 알아보자

![image](https://prototechsolutions.com/wp-content/uploads/2020/02/blog-image-3-website.png)



### 고통의 구역

-   (0, 0) 주변 구역에 위치한 컴포넌트는 매우 안정적이며 구체적이다.
    -    뻣뻣한 상태이기 때문에, 추상적이지 않아서 확장할 수 없고, 안정적이므로 변경하기 상당히 어렵다.

하지만 변동성이 없는 컴포넌트는 (0, 0) 구역에 위치하더라고 해롭지 않다. 변동될 가능성이 거의 없기 때문이다.



### 쓸모 없는 구역

-   (1, 1) 주변의 컴포넌트는 최고로 추상적이다.
    -   하지만, 누구도 그 컴포넌트에 의존하지 않는다. 

이러한 컴포넌트는 쓸모가 없다. 따라서 이 구역은 쓸모없는 구역(Zone of Uselessness)이라고 부른다.



### 배제 구역 벗어나기

-   변동성이 큰 컴포넌트는 두 배제 구역으로부터 가능한 멀리 떨어뜨려야한다.
-   각 배제 구역으로부터 가장 멀리 떨어진 곳을 주계열이라 부르며, 주계열 위 또는 가깝게 위치해야 하며, 이렇게 위치하면 '너무 추상적'이지도 않고, 추상화 정도에 비해 '너무 불안정'하지도 않다.



### 주계열과의 거리

-   컴포넌트가 주계열 바로 위에, 또는 가까이 있는 것이 바람직하다면, 이 같은 이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어 볼 수 있다.

-   D : 거리. D = | A + I - 1| 
    -   D가 0이면 컴포넌트가 주계열 바로 위에 위치한다는 뜻이며, 1이면 가장 멀리 있다는 뜻.
-   D거리 지표를 통해 주 계열에서 멀리 벗어난 컴포넌트의 원인을 파악하고 조사해 볼 가치가 있다.



## 결론

-   이 장에서 설명한 의존성 관리 지표는 설계의 의존성과 추상화 정도가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
    -   저자는 경험을 통해 좋은 의존성도 있지만 좋지 않은 의존성도 있다는 것을 배웠으며, '훌륭한' 패턴은 이러한 경험을 반영한다.



# **15. 아키텍처란**

>   아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이다. 시스템을 컴포넌트로 분할하고, 배치하고, 의사소통하는 방법에 따라 정해진다.
>
>   그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

-   아키텍처의 주된 문적은 시스템의 생명주기를 지원하는 것.
-   좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하도록 해준다.



## **개발**

-   5명으로 이루어진팀에서는 모놀리틱한 시스템을 개발할 수 있다.
-   7명씩 이루어진 5개의 팀에서는 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.
    -   다른 요소를 고려하지 않는다면, 이 시스템의 아키텍처는 각 팀 마다 하나씩 발전 될 가능성이 높다.



## **배포**

>   소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 한다. 소프트웨어 아키텍처는 시스템을 한 번에 쉽게 배포할 수 있도록 만드는데 그목표를 두어야한다.

-   초기 개발 단계에서는 배포 전략을 거의 고려하지 않는다.
    -   마이크로서비스 아키텍쳐를 사용하면 개발을 매우 쉽게 할 수 있겠지만, 배포 시기에 여러 마이크로서비스로 인해 문제가 발생할 수 있다.
    -   만약 아키텍트가 초기에 배포를 고려했다면, 더 적은 서비스에서 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며 좀 더 통합된 도구를 사용하여 상호 연결을 관리했을 것이다.



## **운영**

>   운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 덜 든다.

-   운영은 더 좋은 하드웨어로 어느 정도 타협 가능하다.
-   하지만, 좋은 소프트웨어 아키텍쳐는 시스템을 운영하는데 필요한 요구도 알려준다.
    -   시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다.



## **유지보수**

-   유지보수는 탐사와 이로 인한 위험 부담에 있다.
    -   탐사란? 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지 결정할 때 드는 비용.

-   주위를 기울여 신중하게 아키텍처를 만들면, 이 비용을 크게 줄일 수 있다.
    -   서비스를 컴포넌로 분리하고 인터페이스로 격리하는 방식.



## **선택사항 열어 두기**

>   소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 오랫동안 열어 두는 것이다.

-   열어 두어야 할 선택사항은 중요하지 않은 세부 사항을 의미한다.
-   모든 소프트웨어 시스템은 주요한 두 가지 구성요소인 정책(Polciy)과 세부사항(Detail)으로 분해할 수 있다.
    -   정책 요소는 모든 업무 규칙(Business Rules)과 업무 절차(Procuedures)를 구체화 한다.
    -   세부사항은 사람, 외부 시스템, 플그래머가 정책과 소통할 대 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. 
        -   이러한 세부 사항에는 입출력 장치, 데이터 베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.



## 결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.



# 16. 독립성

>   좋은 아키텍쳐는 다음을 지원해야 한다.

-   시스템의 유스케이스
-   시스템의 운영 
-   시스템의 개발
-   시스템의 배포



## 유스케이스

-   시스템 아키텍처는 시스템의 의도를 지원해야한다.
-   행위를 명확히 하며 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만들어야한다.



## 운영

-   각 컴포넌트를 적절히 독립시켜 유지
-   각 컴포넌트간의 통신방식을 제한하지 않음

위 사항을 지킨다면, 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬어질 것이다.



## 개발

-   각 팀이 독립적으로 개발하기 편한 아키텍처가 만들어져야 한다.
-   잘 격리되어 독립적으로 개발가능한 컴포넌트 단위로 시스템을 분할해야하며, 그래야 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다.



## 배포

-   좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야한다.
-   각 컴포넌트를 적절하게 분리하고 격리시켜야한다
    -   마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트들을 올바르게 구동하고 통합하고 관리해야한다.



## 선택사항 열어 놓기

-   아키텍처 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이, 그리고 가능한한 오랫동안 열어 둘 수 있게 해준다.
-   선택사항을 열어둠으로써, 향후 시스템의 변경이 필요할 때 쉽게 변경이 가능하도록 해야한다.



## 계층 결합 분리

-   아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.
-   UI, 유스케이스, DB는 서로 아무 관련이 없다. 아키텍트는 이를 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경될 수 있게 해야한다.
-   이것이 각각의 서로 결합되지 않는 시스템을 수평적으로 분할하는 방법이다.



## 유스케이스 결합 분리

-   각 유스케이스는 UI 일부/앱 특화 업무규칙 일부/앱 독립 업무규칙 일부/DB 일부를 사용한다.
-   유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각이다.
-   ex) 주문 추가 유스케이스의 UI와 주문 삭제 유스케이스의 UI 를 분리.

>    수평은 각 컴포넌트, 수직은 유스케이스를 의미하는 것 같음.



## 결합 분리 모드

-   유스케이스를 위해 수행하는 결합 분리는 운영에 도움이된다.
    -   운영 측면에서는, 결합을 분리할 때 적절한 모드를 선택해야한다.
-   우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야하며, 이것을 선택할 수 있는 선택권을 열어두어야한다.



## 개발 독립성

-   컴포넌트가 완전히 분리되면 팀 사이 간섭은 줄어든다.



## 배포 독립성

-   유스케이스와 계층의 결합이 분리되면, 배포 측면에서 고도의 유연성이 생긴다.
-   결합을 제대로 분리했다면, 운영중에도 유스케이스를 교체하고 추가하는 것이 가능하다.



## 중복

-   코드가 진짜 중복되었다면, 그것은 제거해야한다.
-   하지만 코드가 각자의 경로로 발전한다면, 이것은 중복이 아니다.
    -   화면이 유사한 구조를 가졌다고, 그것을 통합하게 되면 추후 다시 분리하느라 고생할 수 있음.
-   유스케이스를 수직으로 분리할 때, 자동반사적으로 중복을 제거하려는 유혹을 떨쳐내야한다
-   수평으로 분리하는 경우, 대부분의 경우 우발적인 중복이기 때문에 조심하자.



## 결합 분리 모드 ( 다시 )

계층과 유스케이스의 결합을 분리하는 방법 3가지가 있다.

-   소스코드 수준
    -   소스 코드 모듈 사이의 의존성 제어
    -   함수호출을 통한 통신
-   바이너리 코드 수준
    -   배포 가능한 단위들 사이의 의존성 제어
    -   함수호출을 통한 통신
    -   어떠한 컴포넌트는 다른 프로세서에 상주하여, 프로세스간 통신을 통해 통신 가능
-   실행 단위 수준
    -   서비스 또는 마이크로 서비스를 통한 방식
    -   네트워크를 통한 통신



이러한 분리방식은 프로젝트 성숙도에 따라 최적인 모드가 달라질 수 있다.

-   좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어 추후 선택권을 줄 수 있도록 한다.



## 결론

-   시스템 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영 할 수 있도록 만들어야한다.





# 17. 경계: 선 긋기

>   아키텍처는 선을 긋는 기술이며, 이것을 경계라고 부른다. 

-   경계는 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.
-   어느 선은 매우 초기에 작성되는 경우도 있고, 매우 나중에 그어지는 경우도 있다.
-   선은 인적 자원을 최소화하는데 도움을 준다. -> 결합을 최소화함으로써.



## 두가지 슬픈 이야기

-   아키텍트가 너무 일찍 결정을 내려 개발 비용을 엄청 가중시킨 사례



## FitNesse

-   DB 접근에 대한 것을 인터페이스로 두고, Stub을 만드는 방식을 통해 업무규칙과 데이터베이스 사이의 경계선을 그었음.
    -   실제로, MySQL을 도입하기로 마음 먹었을 때 하루만에 MySQL을 사용하는 구현체를 추가할 수 있었음.

-   경계선을 긋는 행위는 결정을 늦추고 연기하는데 도움이 되었고, 시간을 절약시켜주었다.



## 어떻게 선을 그을까? 그리고 언제 그을까?

>   관련이 있는 것과 없는 것 사이에 선을 긋는다.

-   예시) 업무 규칙과 DB에 의존하지 않게 선을 그으면, 업무 규칙은 DB에 대해 하나도 알지 못하며 DB는 업무 규칙을 알 수 있다.



## 입력과 출력은?

>   입력과 출력은 중요하지 않다.

-   인터페이스는 모델에게 있어서 중요하지 않다. 중요한 것은 업무 규칙이다.



## 플러그인 아키텍처

>   데이터베이스와 GUI에 대한 결정을 하나로 합치면, 컴포넌트 추가와 관련된 일종의 패턴이 만들어진다.
>
>   이것이 "플러그인 아키텍처"이다.

-   소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지소바 쉬운 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기이다.
-   나머지 컴포넌트는 업무 규칙으로부터 분리되어 있고, 독립적이다.



## 플러그인에 대한 논의

-   플러그인은 업무규칙의 변경에 따라 완전히 무력화 될 수 있지만, 그 반대는 이루어질 수 없는 비대칭적인 관계이다.
-   이를 통해, 입출력 플러그인의 변경이 업무 규칙에 영향을 끼칠 수 없는 방화벽을 만들 수 있다.



## 결론

-   경계선을 그리려면, 컴포넌트 단위로 분할해야한다.
-   의존성 역전 원칙과 안정된 추상화 원칙을 통해 저수준 세부사항에서 고수준의 추상화를 향하도록 배치하자.



# 18. 경계 해부학

>   경계는 다양한 방식으로 나타나며, 이 장에서 간단히 알아보자.



## 경계 횡단하기

-   경계 횡단은 경계 한쪽에 있는 기능에서 반대편을 호출하여 데이터를 전달하는 일
-   적절한 위치에서 횡단하는 방법은 소스코드 의존성 관리에 있음
    -   의존하는 소스 코드를 다시 컴파일해서 변경하거나 배포해야할지 모르기 때문에, 경계는 방화벽의 역할



## 두려운 단일체

-   단일체는 경계가 드러나지 않는다.
-   저수준이 고수준에 의존한다
    -   클라이언트와 서비스의 고수준/저수준 에 따라 의존성 방향이 달라진다

-   모노리틱 구조의 실행 파일이라도 규칙적인 방식으로 구조를 분리하면, 개발, 테스트, 배포 시 큰 도움이 된다.
    -   고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.



## 배포형 컴포넌트

-   자바의 jar 파일과 같은 동적 링크 라이브러리 등이 배포형 컴포넌트의 예시
-   배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일하다



## 스레드

-   단일체와 배포형 컴포넌트 모두 사용 가능
-   모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수 있음



## 로컬 프로세스

-   로컬프로세스들은 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 각각이 독립된 주소 공간에서 실행된다.

-   메모리 공유가 되지 않으므로 통신은 운영체제 호출, 데이터 마샬링, 프로세스간 문맥교환 등 비싼 작업이다. 
    -   따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.



## 서비스

-   서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
    -   서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수도 있고, 아닐 수도 있다.
    -   모든 통신이 네트워크를 통해 이루어진다.
-   서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 따라서 빈번하게 통신하는 일을 피해야 한다.
    -   latency에 다른 문제를 고수준에서 처리할 수 있어야한다.
    -   고수준 프로세스가 저수준 프로세스의 정보 ( URL 등.. )를 소스코드에 포함하면 안된다.



## 결론

-   단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용
-   서비스의 경계를 활용하는 시스템은 로컬 프로세스 경계도 포함하고 있을 수 있으며, 일련의 로컬 프로세스 퍼사드에 불과할 때가 많음
-   즉, 대체로 한 시스템 안에서도 경계와 지연을 중요하게 고려해야하는 경계가 혼합되어 있음





# 19. 정책과 수준

## 수준

-   수준은 "입력과 출력까지의 거리"이다.

    -   즉, 입출력과 거리가 멀 수록 시스템에서 높은 수준의 컴포넌트를 의미하게 된다.

-   소스 코드는 그 수준에 따라 결합되어야하며, 데이터 흐름을 기준으로 결합되면 안된다. ( 아래가 잘못된 예시 )

    ```kotlin
    fun encrypt() {
        while (true) {
       	    writeChar(translate(readChar()))
        }
    }
    ```

-   이 시스템을 개선하면 아래와 같이 개선할 수 있다.

    ```kotlin
    interface CharReader {
        fun read(): String
    }
    
    interface CharWriter {
        fun write(char: String)
    }
    
    class ConsoleReader : CharReader {
        override fun read(): String {
            // TODO : read from console
        }
    }
    
    class ConsoleWriter : CharWriter {
        override fun write(char: String) {
            // TODO : write to console
        }
    }
    
    class Encrypter(
    	private val charReader: CharReder,
      private val charWriter: CharWriter
    ) {
        fun encrypt() {
          while (true) {
              val input = charReader.read()
              val translated = translate(input)
              charWriter.write(translated)
          }
        }
    }
    
    class Main {
        fun main() {
           val encrypter = Encrypter(ConsoleReader(), ConsoleWriter())
           encrypter.encrypt()
        }
    }
    ```

    -   고수준의 암호화 정책을 저수준의 입출력 정책으로부터 분리시켰다.

        -   이 방식 덕분에 이 암호화 정책을 더 넓은 맥락에서 사용할 수 있다.

            -   암호화 알고리즘의 수정보다 입출력의 수정이 더 빈번할 것을 예상할 수 있다.

        -   입출력에 변화가 발생하더라도, 실제로 암호화 정책은 거의 영향을 받지 않기 때문이다. 

            ```kotlin
            interface CharReader {
                fun read(): String
            }
            
            interface CharWriter {
                fun write(char: String)
            }
            
            class DatabaseReader : CharReader {
                override fun read(): String {
                    // TODO : read from some table
                }
            }
            
            class DatabaseWriter : CharWriter {
                override fun write(char: String) {
                    // TODO : write to some table
                }
            }
            
            class Encrypter(
            	private val charReader: CharReder,
              private val charWriter: CharWriter
            ) {
                fun encrypt() {
                  while (true) {
                      val input = charReader.read()
                      val translated = translate(input)
                      charWriter.write(translated)
                  }
                }
            }
            
            class Main {
                fun main() {
                   val encrypter = Encrypter(DatabaseReader(), DatabaseWriter())
                   encrypter.encrypt()
                }
            }
            ```

            -   실제로 위 코드에서, 입출력을 db로 변화 시켰지만 encrypt 함수에는 수정사항이 존재하지 않는다.



## 결론

-   이 장에서 설명한 정책은 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.
    -   복습을 열심히 해보자.