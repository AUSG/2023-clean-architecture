# 26장 메인(Main) 컴포넌트

>   메인 컴포넌트는 나머지 컴포넌트를 생성하고, 조정하며, 관리한다.



## 궁극적인 세부사항

-   메인 컴포넌트는 궁극적인 세부사항이며, 가장 낮은 수준의 정책이다.
-   메인 컴포넌트는 시스템의 초기 진입점이다.
-   의존성 주입 프레임워크에서 의존성이 주입되는 부분은 메인 컴포넌트여야한다.



## 결론

-   메인 컴포넌트를 애플리케이션의 플러그인으로 생각하자.
    -   설정관련 문제를 쉽게 해결할 수 있다.



# 27장 ‘크고 작은 모든’ 서비스들

>   서비스를 사용하면 상호결합이 분리되는 것처럼 보이지만, 일부만 맞는 말이다. 배포 독립성을 지원하는 것처럼 보이지만, 이것도 일부만 맞는 말이다.



## 서비스 아키첵텨

-   서비스 그 자체로는 아키텍쳐를 정의하지 않는다.

-   아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.
-   서비스도 마찬가지다. 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.



## 서비스의 이점?

### 결합 분리의 오류

-   결합이 분리될거라는 생각은 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.
-   더욱이 공유하는 데이터 때문에 이들 서비스는 강력하게 결합되어 버린다.
    -   서비스를 오가는 데이터의 필드가 추가되면, 모든 서비스에 추가되어야한다.



### 개발 및 배포 독립성의 오류

-   서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.
-   위의 결합 분리의 오류에 따르면, 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것이 아니다.
-   어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.



## 야옹이 문제

-   마이크로 서비스로 택시 서비스를 나눴다고 가정.
    -   Taxi UI
    -   Taxi Finder
    -   Taxi Selector
    -   Taxi Supplier
    -   Taxi Dispatcher

-   고양이를 배달하는 서비스를 운영하려면, 몇 개의 서비스를 수정해야 할까?
    -   전부 다!!!



## 객체가 구출하다

-   컴포넌트 기반 아키텍쳐였다면, 어떻게 해결했을까?
-   서비스 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아들게 했다.
-   추상 기반 클래스를 템플릿 메서드나 전략 패턴등을 이용해서 오버라이드한다.



## 컴포넌트 기반 서비스

-   각 서비스 내부를 컴포넌트 기반 아키텍쳐와 같이, 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다.



## 횡단 관심사

>   아키텍쳐 경계가 서비스 사이에 있지 않다.

-   횡단 관심사를 처리하기 위해서는, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
-   아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.



## 결론

-   서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 아키텍쳐적으로 중요한 요소는 아니다.

-   시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.
-   서비스는 다수의 컴포넌트로 구성할 수 있다.



# 28장 테스트 경계

>   테스트는 시스템의 일부이며. 아키텍처에도 관여한다.



## 시스템 컴포넌트인 테스트

-   테스트는 가장 바깥 원이다.
-   테스트는 독립적으로 배포 가능하다.
-   테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.



## 테스트를 고려한 설계

-   시스템에 강력하게 의존되어 있는 테스트는 깨지기 쉽다.



## 테스트 API

>   테스트가 모든 업무 규칙을 검증하는데 사용할 수 있도록 특화된 API여야한다. 이 API는 인터랙터와 인터페이스 어댑터들의 상위 집합이 될 것이다.



### 구조적 결합

-   테스트가 사용 클래스나 메서드에 구조적으로 결합되어 있으면 깨지기 쉽다.
-   테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는데 있다.



### 보안

-   테스트 API는 운영 시스템에는 배포하지 않도록, 분리되어야한다.



## 결론

-   테스트는 시스템의 일부다.
-   잘 설계하여 깨지지 않도록 해야한다.



# 29장 클린 임베디드 아키텍처

-   세부사항을 잘 숨겨라.
-   하드웨어, 프로세서, OS는 세부사항이다.



# 30장 데이터베이스는 세부사항이다

>   데이터베이스는 엔티티가 아니다. 데이터베이스는 세부사항이며, 일개 소프트웨어일 뿐이다.



## 관계형 데이터베이스

-   관계형 데이터베이스의 기술이 얼마나 뛰어나든, 이는 세부사항이다.
-   외부 원에 위치한 최하위 수준의 함수만 알아야한다.



## 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?

-   디스크 때문이다.
-   디스크의 지연을 해결할 방법과 데이터를 정의 할 표준적인 방식이 필요했다.



## 디스크가 없다면 어떻게 될까?

-   데이터가 데이터베이스에 없고, 파일이나 램에 있더라도 우리는 다루기 편리한 형태로 그 구조를 변경할 것이다.
-   즉, 데이터베이스는 중요하지 않다.



## 세부사항

-   데이터베이스는 그저 메커니즘이며, 장기적으로 저장하는 공간에 지나지 않는다.
-   우리는 데이터가 어떤 형태인지는 절대로 신경쓰면 안된다. 디스크 자체가 존재한다는 사실까지도.



## 하지만 성능은?

-   성능은 업무 규칙과 분리할 수 있는 저수준의 관심사이다.
-   아키텍처와 아무런 관련이 없다.



## 개인적인 일화

-   마케팅적인 이유로 RDBMS를 사용하자는 마케팅 팀과 싸운 얘기 ( 졌음 ) 및 후회



## 결론 

-   체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다.
-   하지만, RDBMS와 SQL은 세부사항일 뿐이다.
-   데이터는 중요하지만, 데이터베이스는 중요하지 않다.