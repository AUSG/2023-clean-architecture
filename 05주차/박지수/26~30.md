## 26장) 메인(Main) 컴포넌트

모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며, 관리한다.

### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다.
- 메인 시스템의 초기 진입점이다.
- 의존성 주입하는 일은 메인 컴포넌트에서 이뤄져야하며, 기반 설비를 생성한 후 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 한다.

### 결론

- 메인 컴포넌트는 클린 아키텍처에서 가장 바깥 원에 위치한다.
- 애플리케이션의 플러그인으로 생각하자 → 외부 자원을 모두 수집한 후 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.

## 27장) ‘크고 작은 모든’ 서비스들

서비스를 사용한다고 상호 결합이 철저하게 분리되는 것은 아니다.

개발/배포 독립성을 지원하는 것처럼 보이지만, 일부만 맞는 말이다.

### 서비스 아키텍처

- 서비스를 사용한다. → 아키텍처에 해당한다고 할 수 없다.
- 아키텍처는 의존성 규칙을 준수하며 고수준/저수준의 세부사항을 분리하는 경계에 의해 정의된다.
- 서비스는 프로세스나, 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.
    - 아키텍처적으로 중요하지 않은 서비스도 존재한다.

### 서비스의 이점?

- 결합 분리의 오류
    - 서비스 사이의 결합이 확실히 분리된다고 예상한다.
        - 인터페이스가 잘 정의 되어 있을 때는 맞다.
        - 네트워크 상의 공유 자원 때문에 결합될 가능성이 존재한다. → 데이터 레코드에 강하게 결합된 상태
- 개발 및 배포 독립성의 오류
    - 각 서비스별로 개발/배포의 독립성이 보장되고, 확장 가능하다고 예상한다.
        - 모노리틱 시스템, 컴포넌트 기반 시스템으로도 구축할 수 있다. (과거에부터 증명됨)
        - 데이터/행위에서 결합되어 있다면 결합된 정도에 맞게 개발/배포/운영 되어야 한다.

### 야옹이 문제

- 서비스 단위로 택시 시스템을 나눴을 때, 새로운 기능/횡단 관심사가 생겼을 때 모든 서비스가 수정되어야 한다.

### 객체가 구출하다

- 컴포넌트 기반 아키텍처에서 컴포넌트 단위로 경계를 나누고 의존성 규칙을 준수한다면, 기능 결합이 분리되고 독립적으로 개발 배포 할 수 있다.

### 컴포넌트 기반 서비스

- 서비스가 반드시 소뮤도 단일체여야 할 이유가 없다.
- 서비스 내부를 컴포넌트 기반으로 만들면, 파생 클래스를 만드는 방식으로 신규 기능 추가할 수 있다. → 개방 폐쇄 원칙 준수

### 결론

- 서비스는 시스템의 확장성/개발 가능성 측면에서 유용 하지만 아키텍처적으로 중요한 요소가 아니다.
- 아키텍처는 전체 시스템 내부에 그어진 경계를 넘나드는 의존성에 정의되어야 한다.
    - 통신/실행 하는 물리적인 메커니즘에 의해 아키텍처가 정의되는 것은 아니다.

## 28장) 테스트 경계

테스트는 시스템의 일부이며, 아키텍처에도 관여한다.

### 시스템 컴포넌트인 테스트

- 테스트는 클린 아키텍처에 가장 바깥 쪽 원이다.
- 테스트는 독맂버으로 배포 가능하다. → 테스트는 테스트 시점에만 배포하고 사용 시스템에는 배포하지 않는다.

### 테스트를 고려한 설계

- 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고 시스템은 뻣뻣해져서 변경하기 어려워진다.
- 시스템에 강하게 결합된 테스트라면 시스템 컴포넌트에 생긴 아주 사소한 변경에 테스트가 망가질 수 있다.

### 테스트 API (잘 모르겠어여)

- 보안 제약사항을 무시하고, 값비싼 자원(데이터베이스) 건너 뛰어 시스템을 테스트 가능한 특정 상태로 강제하는 힘을 지녀야 한다.
- 애플리케이션으로부터 분리할 목적으로 사용한다.

### 결론

- 테스트는 시스템 외부에 있지 않다. → 시스템에 일부로 깨지지 않게 잘 설계해야한다. → 나중에 버리지 않게…ㅠ

## 29장) 클린 임베디드 아키텍처

소프트웨어는 닳지 않지만, 펌웨어/하드웨어는 낡아 간다. → 소프트웨어도 수정해야한다.

- 하드웨어와 업무 규칙을 최대한 분리해야한다.
    - 분리하지 않으면 하드웨어가 바뀔 때마다 업무 규칙도 다시 개발해야 할 것이다.
- 테스트 하기 쉬운 아키텍처로 만들어야한다.
    - 계층 (소프트웨어/펌웨어/하드웨어)를 잘 나눠 정책을 잘 테스트 해야한다.
- 하드웨어/프로세서/OS는 세부사항이다.
- **인터페이스를 통하고, 대체 가능성을 높이는 방향으로 프로그래밍하라**

## 30장) 데이터베이스는 세부사항이다

아키텍처 관점에서 데이터베이스는 엔티티가 아니다. → 세부사항이고 아키텍처의 구성요소 수준으로 끌어올릴 수 없다.

### 관계형 데이터베이스

- 결국 데이터를 가져오는 기술일 뿐이고, 이는 세부사항이다.
- 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야 한다.
- 디스크 지연을 해결할 방법과 데이터를 정의할 표준적인 방법이 필요했고, RDB를 많이 사용하게 되었다.
    - 우리는 데이터를 가져온 후, 데이터베이스의 Row 단위가 아니라 다루기 편리한 자료구조로 변경하여 사용한다.
    - 즉, 데이터베이스는 중요하지 않다.

### 성능은?

- 성능은 업무 규칙과는 분리할 수 있는 관심사다.
- 시스템 전반적인 아키텍처와는 아무런 관련이 없다.

### 결론

- 체계화된 데이터 구조, 데이터 모델은 중요하다.
- 하지만 데이터를 저장하는 테이블 구조/디스크를 읽는 방식은 우리의 관심사가 아니다.
