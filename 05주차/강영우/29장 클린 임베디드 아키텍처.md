# 29장 클린 임베디드 아키텍처

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.
+ 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.
> 

펌웨어를 수없이 양산하는 일을 멈추고, 코드에게 유효수명을 길게 늘릴 수 있는 기회를 주어라.

# 앱-티튜드 테스트

---

- 켄트 벡의 소프트웨어를 구축하는 세 가지 활동
    - 먼저 동작하게 만들어라. + 사업 망하기 싫으면
    - 그리고 올바르게 만들어라 + 리팩터링 가능하게 만들어라
    - 그리고 빠르게 만들어라 + 리팩터링으로 요구되는 성능을 만족 시켜라
- 앱-티튜드 테스트: 앱이 동작하도록 만드는 것.
- 앱-티튜드 테스트를 통과하더라도 클린 임베디드 아키텍처를 가진 것은 아니다.

# 타깃-하드웨어 병목현상

---

- 임베디드는 하드웨어적인 요소를 더 많이 생각해야하고 여기서 오는 소프트웨어 개발의 속도 저하가 있다.
- 타깃-하드웨어 병목현상: 클린아키텍처 원칙을 따르지 않고 개발을 하면, 테스트할 수 있는 기기가 국한되어 병목현상이 생긴다.

## 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다.

타깃-하드웨어 병목현상을 줄여보자

### 계층

- “하드웨어 - 펌웨어 - 소프트웨어”로 나뉘어 개발되어야 한다. 소프트웨어와 펌웨어가 혼합되어서 개발되면 안된다.

### 하드웨어는 세부사항이다.

- 하드웨어 추상화 계층(HAL): 소프트웨어와 펌웨어 사이의 결계
- 저장공간 등은 HAL이 정하고 소프트웨어는 로직만 갖는다.

## HAL 사용자에게 하드웨어 세부사항을 드러내지 말라

- 클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계없이 테스트가 가능하다.

### 프로세서는 세부사항이다.

- 프로세서에 종속되면 안된다.
- C가 해당 프로세서에 종속되어버리면 더이상 C가 아니게 되어버린다.
- 레지스터를 알고 사용하는 것은 “펌웨어”가 되어야 한다.
- 마이크로 컨트롤러를 사용할 때, 펌웨어가 저수준 함수들을 프로세서 추상화 계층(PAL)의 형태로 격리시켜줄 수 있다.

### 운영체제는 세부사항이다.

- HAL은 필수적이다. 하지만 실시간 운영체제를 사용하거나, 임베디드 버전의 OS를 사용하면 HAL로는 충분하지 않다.
- 운영체제를 세부사항으로 취급하고 운영체제를 의존하지 않아야 코드의 수명이 늘어난다.
- “하드웨어 - 펌웨어 - OS - 소프트웨어” 여기에 운영체제 추상화 계층(OSAL)를 통해 소프트웨어를 운영체제로부터 격리 시켜야한다.
- “하드웨어 - 펌웨어 - (HAL) - OS - (OSAL) - 소프트웨어”
- 이러면 코드가 많아질 수 있지만 큰 비용을 추가로 초래하지는 않는다.
- OSAL은 테스트 지점을 만드는데도 도움이 된다.

## 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍 하라.

- 관심사를 분리시키고, 인터페이스를 활용하며, 대체 가능성을 높이는 방향으로 프로그래밍하도록 유도한다.
- 계층형 아키텍처는 인터페이스를 통해 프로그래밍 하자는 발상을 기반으로 한다.
    - 모듈들이 서로 인터페이스를 통해 상호작용한다면 특정 서비스 제공자를 다른 제공자로 대체할 수 있다.
- 오직 구현체에서만 필요한 데이터 구조, 상수, 타입 정의들로 인터페이스 헤더 파일을 어지럽히지 말라.
    - 원치 않는 의존성을 가지고 올 것이다.
    - 구현 세부사항의 가시성을 제한하고, 변경될 것임을 가정하라.
- 클린 임베디드 아키텍처에서 모듈들이 인터페이스를 통해 상호작용하기 때문에 각각 계층 내부의 테스트가 가능하다.

## DRY 원칙: 조건부 컴파일 지시자를 반복하지 말라.

- 코드를 반복하는 일을 반복하지 마라(DRY)
- 하드웨어 추상화 계층을 만들어 일련의 인터페이스를 제공하면 소프트웨어와 하드웨어를 바인딩을 통해 사용 가능하다.

# 결론

---

임베디드 소프트웨어는 특별하다. 그렇지만 코드수명을 늘릴 수 있는 방법은 비슷하다.