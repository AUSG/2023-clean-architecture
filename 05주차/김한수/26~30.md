# 26~30

- [26~30](#2630)
- [26. 메인(Main) 컴포넌트](#26-메인main-컴포넌트)
  - [요약](#요약)
- [27. ‘크고 작은 모든’ 서비스들](#27-크고-작은-모든-서비스들)
  - [서비스 아키텍처?](#서비스-아키텍처)
  - [서비스의 이점?](#서비스의-이점)
    - [개발 및 배포 독립성의 오류](#개발-및-배포-독립성의-오류)
  - [횡단 관심사](#횡단-관심사)
  - [결론](#결론)
- [28. 테스트 경계](#28-테스트-경계)
  - [시스템 컴포넌트인 테스트](#시스템-컴포넌트인-테스트)
  - [테스트를 고려한 설계](#테스트를-고려한-설계)
    - [깨지기 쉬운 테스트(Fragile Tests)](#깨지기-쉬운-테스트fragile-tests)
  - [테스트 API](#테스트-api)
  - [구조적 결합](#구조적-결합)
  - [보안](#보안)
  - [결론](#결론-1)
- [29. 클린 임베디드 아키텍처](#29-클린-임베디드-아키텍처)
  - [앱-티튜드 테스트](#앱-티튜드-테스트)
- [30. 데이터베이스는 세부사항이다](#30-데이터베이스는-세부사항이다)

# 26. 메인(Main) 컴포넌트

- 모든 시스템에는 최소한 하나의 컴포넌트가 존재하고 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며, 관리한다
- 우리는 이 컴포넌트를 `메인(Main) 컴포넌트`이라고 부른다.

## 요약

`메인 컴포넌트`의 핵심 특징은 다음과 같다.

- 클린 아키텍처에서 가장 바깥 원에 위치하는 `지저분한 저수준의 모듈`이다
- 고수준의 시스템을 위한 모든 것을 로드한 후 제어권을 고수준의 시스템에게 넘긴다. (`Injection`)
- 메인 컴포넌트를 언제든 갈아끼울 수 있는 플러그인으로 여기고, 아키텍처 경계 바깥에서 위치한다고 바라보면 `설정 관련 문제`를 훨씬 쉽게 해결할 수 있다.

# 27. ‘크고 작은 모든’ 서비스들

**서비스 지향 아키텍처와 마이크로서비스 아키텍처는 최근에 큰 인기를 끌고 있다.**

그 이유는 다음과 같다.

- 서비스를 사용하면
  - **상호 결합이 철저하게 분리되는 것처럼 보인다.**
  - **그리고 개발과 배포 독립성을 지원하는 것처럼 보인다.**

**하지만 이것들은 일부만 맞는 말이다.**

## 서비스 아키텍처?

**서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하지는 않는다.**

- 시스템의 아키텍처는 의존성 규칙을 준수하며 컴포넌트 경계에 의해 정의된다.
- 단순히 애플리케이션의 행위(함수)를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며,
아키텍처 관점에서 꼭 중요하다고 볼 수는 없다
- `모놀리틱`**에서도 이런 함수의 경계는 나눌 수 있다. 그래서 단순히 서비스를 사용하는 것은 아키텍처적으로 중요한 요소는 아니다.**
- 그렇다고 모든 서비스가 반드시 아키텍처 관점에서 중요해야만 한다는 말은 아니다.
  - 그러나 기능을 프로세스나 플랫폼에 독립적으로 서비스들을 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 될 때가 많다.

## 서비스의 이점?

서비스 아키텍처라는 통설에 대해 여기서 이의를 제기해보고 이점을 따져보자

- 시스템을 서비스들로 분리함으로써 얻게 되는 큰 이점 중에 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다.
  - 이건 어느정도 일리가 있지만 사실 서로 공유하는 데이터가 있는 경우 각 서비스는 강하게 결합된다.
  - 새로운 필드를 추가하거나 하는 경우 각 서비스 간 적절하게 타협해야하고 결국 간접적으로 결합하게 되어버린다.
- 서비스 분리 시 모든 서비스의 인터페이스는 반드시 잘 정의되어야 하고 의도적으로 그렇게 정의하게 된다.
  - 이는 사실 함수의 경우에도 크게 다르지 않고 실제로 서비스 인터페이스가 함수 인터페이스보다 더 엄밀하고 엄격하거나, 더 잘 정의되는 건 아니다. 그래서 큰 의미가 없다.

**즉 위 통설에 기반해서 반론해보면 사실 서비스를 분리하는 것은 큰 이점이 없을 수 있다는 말이다.**

### 개발 및 배포 독립성의 오류

- **서비스를 사용함에 따라 각 서비스를 관리하는 전담팀이 서비스를 소유하고 운영하게 되는 것도 이점이다.**
  - 그래서 devops 전략의 일환으로 전략팀에서 각 서비스를 유지보수하고 운영하는 책임을 질 수 있다.
  - 그리고 이러한 개발 및 배포 독립성은 확장가능한 것으로 간주된다.
  - 또한 대규모 엔터프라이즈 시스템을 독립적으로 개발하고 운영 및
    수천, 수백개의 많은 서비스들로 분리하여 이용하여 만들 수 있고
    또, 그 서비스에 비슷한 수의 독립적인 팀 단위로 분할할 수 있다고 여겨진다.
- **하지만 정말 그럴까?**
  - 사실 대규모 엔터프라이즈 시스템은 굳이 서비스를 분리하지 않아도 모놀리틱이나 컴포넌트 기반 시스템으로 충분히 구축할 수 있다는 것은 역사적으로 증명되어 있다.
    - 따라서 서비스를 분리하는 것은 확장 가능한 시스템을 구축하는데 유일한 선택지는 아니다.
  - 그리고 `결합 분리의 오류` 에 따르면 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니다.
    - 데이터나 행위에서 어느정도 결합된 서비스들이 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다. (=달리는 자동차의 바퀴 바꾸기)

## 횡단 관심사

서비스를 분리하더라도 아키텍처의 경계는 사실 서비스 사이에 있지 않다.
비즈니스 요구사항에 의해서 필연적으로 `횡단 관심사` 라고 불리는 공통의 관심사가 생기게된다.

- e.g. 택시 통합 서비스에서 고양이 배달 기능을 추가한다고 해보자
  - 기존에 택시를 공급하던 프로세스는 유지할 수 있겠지만, 어떤 운전자는 고양이 알러지가 있따는 등 고양이 배달과 관련된 비즈니스 조건들을 충족하기 위해서는 거의 모든 서비스에서 수정사항이 생길 것이다.

**따라서 아키텍처 경계는 서비스 사이에 있지 않고 오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.**

- 모든 주요 시스템이 직면하는 횡단 관심사를 해결하려면 아래 그림처럼 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.

![1.png](https://user-images.githubusercontent.com/72328687/224510781-ce481412-4749-4ad9-a30d-84e39555fc64.png)

**결론적으로 이 서비스들은 시스템의 아키텍처 경계를 정의하지 않는다.
아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.**

## 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.
  - 즉. 시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의되는 것은 아니다.
  - **시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해서 정의된다.**
- 서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다. 혹은 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.
  - 그렇지만 클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없는 경우도 드물지 않게 존재한다.

# 28. 테스트 경계

**테스트는 시스템의 일부이며, 시스템의 나머지 요소가 아키텍처에 관여하는 것과 동등하게 아키텍처에도 관여한다.
어떤 면에서는 정말 평범하게 관여하지만, 다른 면에서는 상당히 독특하게 관여한다.
이 케이스에 대해서 알아보자**

## 시스템 컴포넌트인 테스트

- `테스트`는 시스템의 일부이다.
- 테스트는 테스트는 세부적이며 구체적인 것으로 의존성은 항상 테스트하는 코드를 향한다.
즉, 태생적으로 `의존성 규칙`을 따른다.
- 테스트는 독립적으로 배포 가능하다.
  - 대다수의 경우 테스트는 테스트 시스템에만 배포하며 사용 시스템에는 배포하지 않는다.
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.
  - 테스트는 시스템 운영에 꼭 필요치 않고, 어떤 사용자도 테스트에 의존하지 않는다.
  - 테스트의 역할은 운영이 아니라 안정적인 개발을 지원하는 데 있다.
    - **그렇지만 사실 많은 면에서 테스트는 다른 모든 시스템 컴포넌트가 반드시 지켜야하는 모델을 표현하기에 중요하다.**

## 테스트를 고려한 설계

개발자는 종종 테스트가 설계 범위 밖에 있다고 여기지만,
**이 관점은 치명적이다.**

- 테스트가 시스템의 설계와 잘 통합되지 않으면
- 테스트는 깨지기 쉬워지고
- 시스템은 유연함을 잃고 뻣뻣해져서 변경하기 어려워진다.

### 깨지기 쉬운 테스트(Fragile Tests)

- **시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야만 한다.**
그래서 시스템 컴포넌트에 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다.
  - 그런데 시스템의 공통 컴포넌트가 변경된다면?
  - 수백, 심지어 수천 개의 테스트가 망가질 수 있다.
  - 이 문제는 `깨지기 쉬운 테스트 문제(Fragile Tests Problem)`로 알려져 있다.
- **깨지기 쉬운 테스트는 언제 어떻게 생성될까?**
  - GUI같은 변동성이 큰 경우. 즉, 변동성이 있는 것에 의존할 때 발생한다.
  - 깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만드는 부작용을 낳는다.
  - 시스템의 간단한 변경이 1000개 가량의 대량의 테스트 실패로 이어진다면?
    개발자는 그러한 변경을 하지 않으려 들 것이고 이해 관계자와 하게될 대화가 어떨지 상상해보자.. 벌써 끔찍하다..
- 변동**성이 있는 것에 의존하지 말라.**
  - GUI는 변동성이 크다 따라서 GUI로 시스템을 조작하는 테스트는 분명히 깨지기 쉽다.
  - **따라서 시스템과 테스트를 설계할 때, GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 한다.**

## 테스트 API

**모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된** `테스트 API`**를 만들면 깨지기 쉽고, GUI 같은 것을 사용하지 않고 중요한 업무 규칙을 테스트할 수 있다.**

- 이러한 API는 보안 제약사항을 무시하고, DB같은 값비싼 자원은 건너뛰고 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야만 한다.
- 이 API는 결국 사용자 인터페이스가 사용하는 `인터랙터(interactor)`와 `인터페이스 어댑터(interface adaptor)`들의 상위 집합이 될 것이다.

- 그리고 `테스트 API`는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.
  - **단순히 테스트를 UI에서 분리하는 것만이 아닌, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는 게 목표!**

## 구조적 결합

- `구조적 결합`은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져 나가는 유형이다.
- **모든 상용 클래스, 상용 메서드에 테스트 클래스, 테스트 메서드가 각각 존재한다면?**
  - **이는 애플리케이션 구조에 강하게 결합되게 된다.**
- **테스트 API의 역할은 이런 애플리케이션 구조를 테스트로부터 숨기는 데 있다.**
  - 이렇게 만들면 상용 코드를 리팩토링하거나 진화시키더라도 테스트와 상용 코드가 서로 독립적으로 진화할 수 있다.

- **구조적 결합이 강하면 필수적인 진화 과정을 방해할 뿐만 아니라 상용 코드의 범용성과 유연성이 충분히 좋아지지 못하게 막는다는 점을 명심하자.**

## 보안

**테스트 API는 강력하지만 실제 운영 환경에 배포한다면 보안 측면에서 위험에 처할 수 있다.**

- 따라서 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야한다.

## 결론

- 테스트는 시스템의 일부이다.
  - 따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계되어야한다.
  - 그렇지 않으면 서비스는 깨지기 쉽고 유지보수하기 어렵게 될 것이다. 그리고 이런 테스트는 유지보수하기 너무 어렵기 때문에 휴지처럼 버려질 수도 있다.

# 29. 클린 임베디드 아키텍처

- 펌웨어부터 하드웨어, OS, 소프트웨어까지 임베디드 개발에서 인터페이스를 어떻게 나누는 것이 변경에 유연하게 설계할지에 대한 이야기
- 각 레이어별 세부사항에 대해서 이야기하고 이는 인터페이스로 관리해라는 내용

## 앱-티튜드 테스트

켄트 벡(Kent Beck)이 말한 소프트웨어를 구축하는 세 가지 활동과 저자의 추가 해석

- `먼저 동작하게 만들어라`
  - 소프트웨어가 동작하지 않는다면, 사업은 망한다
- `그리고 올바르게 만들어라`
  - 코드를 리팩터링해서 당신을 포함한 나머지 사람들이 이해할 수 있게 만들고, 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라.
- `그리고 성능이 빠르게 만들어라`
  - 코드를 리팩토링해서 요구되는 성능을 만족시켜라

# 30. 데이터베이스는 세부사항이다

데이터베이스가 어떻게 데이터를 저장하는지, RAM에 저장하는지 하드디스크에 저장하는지에 대한 내용은 세부사항이다.

- 체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하지만 그저 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 데이터를 영구히 저장하는 기술과 시스템은 아키텍처적으로 중요하지 않다.
