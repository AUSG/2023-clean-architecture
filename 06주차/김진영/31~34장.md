## 31. 웹은 세부사항이다.

웹의 등장 이후 아키텍처의 중심이 앞 단에 웹과 뒷 단에 서버 사이를 끝없이 반복하는 추와 같이 오가고 있다. 하지만 GUI는 세부사항이고, 웹은 GUI이기 때문에 웹은 세부사항이 맞다. 때문에 쉽지않지만 UI와 애플리케이션을 추상화 경계로 분리하고자 노력해 중요한 것과 중요하지 않은 것을 분리해내야 한다.



## 32. 프레임워크는 세부사항이다

프레임워크는 우리의 문제를 해결하기 위해 만들어진 것이 아니라 우리를 잘모르는 제작자의 문제를 해결하기 위해 만들어졌다. 프레임워크에 문제가 생겨도 프레임워크 제작자가 우리에게 책임지는 것은 없다. 때문에 프레임워크와 결혼하지 말라. 가급적 프레임워크를 가능한 한 오랫동안 아키텍처 경계 너머에 두자. 아마 젖소를 사지 않고도 우유를 얻는 방법을 찾을 수 있을 것이다.



## 33. 사례 연구: 비디오 판매

1) 유즈케이스 분석

액터 중 하나를 위해 기능 변경이 변경될 것이다. 따라서 특정 액터를 위한 변경이 나머지 액터에게 전혀 영향을 미치지 않게 만들어야 한다. “라이선스 구매하기는” 추상 유즈케이스로 범용적인 정책을 담고 있고, 다른 유스케이스에서 이를 더 구체화한다. “카탈로그 조회하기”는 분리할수도 있지만 유사성을 식별해 분석 초기에 통합하기로 했다.

![Untitled](img/Untitled.png)

2) 컴포넌트 아키텍처

각 컴포넌트를 독립적으로 컴파일하고 빌드할 수 있는 환경을 구성하면, 후에 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.

![Untitled](img/Untitled%201.png)

3) 의존성 관리

제어의 흐름이 항상 저수준에서 고수준을 향하도록 구성한다. 이를통해 저수준의 세부사항에서 발생한 변경이 상위로 파급되지 않음을 보장할 수 있다.

4) 결론

그림 33.2의 아키텍처는 1) 단일 책임 원칙에 기반한 액터의 분리 2) 의존성 규칙 두 가지 서로 다른 차원의 분리가 되어 있다. 이 두 차원은 모두 서로 다른 이유(= 엑터)로, 서로 다른 속도(= 정책 수준)로 변경되는 컴포넌트를 분리하는데 그 목적이 있다. 이런 방식으로 코드를 구조화 함으로서 배포하는 방식을 다양하게 가져갈 수 있게된다.



## 34. 빠져 있는 장

1) 계층 기반의 패키지

Presentation Domain Data 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합할 수 있다. 하지만 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다는 문제도 있다.

![Untitled](img/Untitled%202.png)

2) 기능 기반 패키지

코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다. 하지만 이 방법 또한 계층 기반의 패키지와 같이 차선책이다.

![Untitled](img/Untitled%203.png)

3) 포트와 어댑터

com.mycompany.myapp.domain 패키지가 내부, 나머지는 모두 외부이다. 의존성이 내부를 향해 흐른다.

![Untitled](img/Untitled%204.png)

![Untitled](img/Untitled%205.png)

4) 컴포넌트 기반 패키지

컴포넌트를 단순히 배포단위로 보는 것이 아니라. 인터페이스로 감싸진 연관된 기능들의 묶음으로 본다면 아래와 같이 구성할 수 있다. 컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직 한 곳, 즉 OrdersComponent만 둘러보면 된다는 점이다. 이와 같이 모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 마이크로서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.

![Untitled](img/Untitled%206.png)

5) 구현 세부사항엔 항상 문제가 있다 + 6) 조직화 vs. 캡슐화

모든 Class를 public으로 열어두면 캡슐화의 이점을 살릴 수 없다. 자바의 패키지는 조직화를 위한 메커니즘으로 전락하여 캡슐화로 사용될 수 없는 것이다. 아키텍처 원칙을 강제할 때 자기 규율이나 컴파일러 후처리 도구를 사용하지 말라. 접근제한자를 활용하여 반드시 컴파일러에 의지해라.

![Untitled](img/Untitled%207.png)

6) 결론

최적의 설계를 했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다. 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 항상 고민하라. 가능하면 선택지를 열어두되, 실용주의적으로 행하라. 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지를 고민하며, 데이터 모델과 같은 다른 영역에 결합되지 않도록 주의하라.