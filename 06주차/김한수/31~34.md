# 31~34

# 31. 웹은 세부사항이다

## 요약

- **웹을 비롯한 GUI는 세부사항이다. 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야한다.**
  - UI는 자주 바뀌고 웹 브라우저와의 결합도 때문에 장치 독립성은 비현실적이라고 주장하기 쉽다.
  - 하지만 UI와 애플리케이션 사이에는 추상화 가능한 업무 로직 즉 다수의 `유즈케이스`가 존재할 수 있다.
  - 이런 `유즈케이스`들은 독립적으로 가져갈 수 있을 것이다.

## 결론

- 웹을 비롯한 GUI에서는 추상화를 만들기 쉽지 않고
제대로 만드려면 **수차례의 반복 과정을 거쳐 진화해야할 것이다.**

# 32. 프레임워크는 세부사항이다

- 프레임워크는 상당히 인기를 끌고 있고 이는 일반적으로 좋은 현상이다.
- 무료이고 강력하며 유용한 프레임워크가 많다.
  - **하지만 아무리 해도 프레임워크는 아키텍처가 될 수 없다.**

## 프레임워크 제작자는 당신을 모른다

- 프레임워크 제작자는 커뮤니티에 도움이 되기를 바라는 마음으로 자신의 작업물을 무료로 제공한다.
- **마음은 이쁘지만 프레임워크 제작자는 당신을 모르기 때문에 당신이 풀어야 할 관심사를 염두에 두고 있지 않다.**
- 물론 당신의 문제는 프레임워크가 풀려는 문제와 꽤 많이 겹칠 것이다. 그렇기에 인기가 있는 것이고 이 겹치는 영역이 클수록 프레임워크는 실제로 더 유용해진다.

## 프레임워크와의 혼인 관계 비대칭성

- 당신과 프레임워크 제작자 사이의 관계는 놀라울 정도로 `비대칭적`이다.
  - 당신은 프레임워크를 위해 대단히 큰 헌신을 해야 하지만,
  - 프레임워크 제작자는 당신을 위해 아무런 헌신도 하지 않는다.

- 프레임워크 제작자는 당신에게 일방적인 혼인 관계를 요구한다.
  - 프레임워크 제작자는 결합을 피하라는 프레임워크 사용자와는 다르게
  - 프레임워크와 강하게 결합될 것을 요구한다.
  - 이 결합은 당신에게 위험할 수 있지만 프레임워크 제작자에게는 위험요소가 아니다.

## 위험 요소

**그렇다면 프레임 워크의 위험 요인들은 무엇일까? 이를 정리해보자**

- 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많다.
  - `의존성 규칙을 위반하는 경우`
    - 프레임워크 제작자는 당신만의 고유한 엔티티를 만들 때 프레임워크 제작자는 자신의 코드를 상속할 것을 요구한다.
    - 프레임워크 제작자는 자신의 프레임워크가 당신의 가장 안쪽 원과 결합되기를 원하고 프레임워크가 이 원 안으로 한번 들어가버리면 다시는 원 밖으로 나오지 않을 것이다.
    - 결혼반지는 끼워졌고 다시는 빼지 못하는 꼴이다.
  - `제품이 성숙해지면 프레임워크가 제공하는 기능과 틀을 벗어나게 될 때가 있다`
    - 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 될 것이다.
    - 하지만 시간이 지나면서 제품이 성숙해지고 프레임워크와 계속 싸우고 있는 자신을 발견하게 될 것이다.
  - `프레임워크는 당신에게 도움되지 않는 방향으로 진화할 수도 있다`
    - 도움도 되지 않는 신규 버전으로 업그레이드하느라 다른 일을 못 할수도 있고
    - 심지어 사용 중이던 기능이 사라지거나 반영하기 힘든 형태로 변경될 수도 있다.
  - `새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다`

## 해결책

**그렇다면 위 위험요소들에 대한 해결책은 무엇일까?**

> **프레임워크와 결혼하지 마라!**


- **프레임워크를 사용할 수는 있지만, 프레임워크와 결합해서는 안된다.**
  - 적당히 거리를 두고 프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항으로 취급하라
  - 그리고 프레임워크가 아키텍처의 원 안쪽으로 들어오지 못하게하라.
- 업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면
  - 이를 거절하고 대신 proxy를 만들고 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 proxy를 위치시켜 우회하라
  - **의존성 규칙을 준수하기 위해서 절대로 프레임워크가 핵심 코드 안으로 들어오게 해서는 안된다!**
- 예를 들어 Spring Framework의 경우 `@Autowired` 어노테이션을 사용할 수 있는데, 이게 업무 객체 도처에 산재해서는 안된다. **업무 객체는 절대로 스프링에 대해서 알아서는 안 된다.**
  - 차라리 업무 객체보다는 메인 컴포넌트에서 스프링을 사용해 의존성을 주입하는 편이 낫다.
  - 메인은 아키텍처 내에서 가장 지저분한, 최저 수준의 컴포넌트이기 때문에 스프링을 알아도 상관없다.

# 33. 사례 연구: 비디오 판매

이 장에서는 짧고 간단한 사례로 뛰어난 아키텍트가 일을 처리하는 과정과 결정을 내리는 모습을 보여준다.

- **먼저 서비스에 대해서 이해하고 초기 아키텍처를 결정하기 위해 액터와 유스케이스를 식별한다**
  - 그리고 이 식별된 정보를 가지고 특정 택어를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 할 수 있도록 시스템을 분할한다.
  - 유스케이스 중에 일부 겹치는 경우가 있을텐데 이는 `추상 유스케이스` 로 분류하여 추상화할 수 있다.
    - 사실 이 추상 유스케이스가 없더라도 문제는 없고 이 추상화를 꼭 생성해야만 하는 것은 아니었으나 여기서는 유사성을 식별해 분석 초기에 통합하는 방법을 찾는 편이 더 현명하다고 판단한다.

## 컴포넌트 아키텍처

- 액터와 유스케이스를 식별하면 아래와 같이 `예비 단계의 컴포넌트 아키텍처`를 구성해볼 수 있다.
  - 각각 `View`, `Presenter`, `Interactor`, `Controller` 로 분리된 전형적인 분할 방법을 확인할 수 있고 **각 액터에 따라 카테고리를 분리한 것을 알 수 있다.**
  - 그리고 중간에 `Catalog View`, `Catalog Presenter` 는 추상 클래스로 생성될 것이다.

![1](https://user-images.githubusercontent.com/72328687/225626544-09acff90-6ec2-410e-bc66-bccc44cd57e7.png)

## 의존성 관리

위 컴포넌트 아키텍처를 살펴보면 `의존성 규칙`을 준수하고 의존성(제어흐름)이 단방향으로 흐른다는 것을 알 수 있다.

- **항상 의존성이 올바른 방향으로 흐르게하고 저수준의 세부사항에서 발생한 변경이 상위로 파급되어서 상위 수준의 정책에 영향을 미치지 않음을 보장하자.**

# 34. 빠져 있는 장

클린 아키텍처는 잠시 한쪽으로 제쳐 놓고, **설계나 코드 조직화와 관련된 몇가지 접근법을 살펴보자.**

## 계층 기반 패키지

- 가장 단순한 첫 번째 설계 방식은 전통적인 `수평 계층형 아키텍처`다.
  - 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다.
  - 전형적으로 웹, 업무 규칙, 영속성 코드를 위해 계층이 각각 하나씩 존재하게된다.
- 마틴 파울러는 처음 시작하기에는 계층형 아키텍처가 적합하다고 이야기 했다.
  - 마틴 뿐만 아니라 다수의 책, 튜토리얼 등에서 계층형 아키텍처를 만드는 길로 인도한다.
  - **그리고 실제로 이 아키텍처는 엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 아주 빠른 방법이다.**
- `문제점`
  - **소프트웨어가 커지고 복잡해지기 시작하면, 더 잘게 모듈화해야 할지를 고민하게된다.**
    - 소프트웨어가 커지고 복잡해지면 머지 않아 큰 그릇 3개 만으로는 모든 코드를 담기에 부족하다는 사실을 깨닫고 더 잘게 모듈화해야 할지를 고민하게 될 것이다.
    - 이건 마틴이 언급한 내용이다.
  - **계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다.**
    - 계층형 아키텍처는 전혀 다른 업무 도메인이라도 코드를 계층형 아키텍처로 만들어서 나란히 놓고 보면, 웹, 서비스, 리포지터리로 구성된 모습이 **나쁠 정도로 비슷하게 보일 것이다.**
    - 이건 엉클 밥이 언급한 내용이다.

![2](https://user-images.githubusercontent.com/72328687/225626490-26a0d2e1-e60e-4a1b-9a59-4cf05cd800dc.png)

## 기능 기반 패키지

코드를 조직화하는 또 다른 선택지로는 기능 `기반 패키지 구조`도 있다.

- 이는 `연관된 기능`, `도메인 개념`, 또는 (DDD 용어를 사용한다면)`Aggregate Root`에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.
- 전형적인 구현에서는 모든 타입이 하나의 자바 패키지에 속하며, 패키지 이름은 그 안에 담긴 개념을 반영해 짓는다.
  - 이런 구조는 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다.
  - 아래 코드 코드베이스를 보면 웹, 서비스, 리포지터리가 아니라 주문과 관련한 무언가를 한다는 걸 볼 수 있다.
- 많은 소프트웨어 개발팀이 `수평적 계층화(계층 기반 패키지)` 의 문제를 깨닫고, `수직적 계층화(기능 기반 패키지)` 로 전환하는 게 자주 목격된다.
  - 그러나 이 `수평적 계층화`와 `수직적 계층화` 모두 차선책이다.

![3](https://user-images.githubusercontent.com/72328687/225626529-09af5782-9ebe-4250-9f3e-aabc3caa3950.png)

## 포트와 어댑터

엉클 밥에 따르면 `포트와 어댑터` 혹은 `헥사고날 아키텍처`, `경계, 컨트롤러 엔티티` 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서다

- → 내부(도메인)와 외부(인프라)로 분류하여 `내부 코드를 보호`
- **의존성 규칙을 지키며 외부가 내부에 의존하도록**

![4](https://user-images.githubusercontent.com/72328687/225626531-d44af100-fb83-487f-aea3-13aaecfc87a0.png)

- 위 방식으로 패키지 구조를 잡아보면 아래와 같다.
  - 여기서 `OrderRepository` 가 `Orders`라는 간단한 이름으로 바뀐 걸 볼 수 있는데,
    이는 DDD 세계관에서 비롯된 명명법이다.
  - DDD에서 `내부`에 존재하는 모든 것의 이름은 반드시 `유비쿼터스 도메인 언어` 관점에서 기술하라고 조언한다.
    - **우리는 도메인에 대해 논의할 때 주문에 대해 말하는 것이지 주문 리포지터리에 대해 말하는 것은 아니다**

![5]((https://user-images.githubusercontent.com/72328687/225626535-7288221c-6b38-4114-b537-f3d4f9b2659f.png)

## 규칙과 현실

- 간혹가다 `Controller` 에서 바로 `Repository` 에 의존하는 코드들이 존재한다.
- 이런 경우를 `완화된 계층형 아키텍처`라고 부른다 (SQRS 패턴 등으로 의도됐을 수도 있다)
  - 하지만 이런 형태를 띄다보면 점점 업무 로직 계층을 우회하게 될 것이고 바람직하지 않다.
- 그래서 우리는 `규칙(아키텍처 원칙)`이 필요하다.
  - e.g `웹 컨트롤러는 절대로 리포지터리에 직접 접근해서는 안된다.`
- 그러나 문제는 강제성..
  - 아무리 규칙을 잘 지키는 신뢰의 훌륭한 팀이라도 현실적으로 자금이 바닥나거나 회사에 위기가 찾아온다면?
  - 그 이후는 어떻게 될지 상상이 될 것이다.
- 소수의 팀만이 빌드 시 정적 분석 도구를 사용해서 아키텍처적인 위반 사항이 없는지 검사하여 자동으로 강제한다고 답한다고 한다.
  - 하지만 이런 방식은 CI 에서 너무 응답이 늦게 올 수 있고
  - 코드 베이스를 엉망진창인 방식(`Big Ball of Mud`)으로 만들어버릴 수 있다.
  - 그래서 저자는 가능하면 컴파일러를 사용해 아키텍처를 강제하는 방법을 선호한다고 한다.

## 컴포넌트 기반 패키지

`컴포넌트 기반 패키지`를 도입해야하는 이유는 바로 위에서 봤던

- 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는 데 주안점을 둔다.
- 이 접근법은 `서비스 중심적인 시각`으로 소프트웨어 시스템을 바라보고
`마이크로서비스 아키텍처가 가진 시각`과 동일하다.
- **Controller를 제외하고 서비스 관련 코드들이 orders 패키지에 모두 담겨있는 모습.**

![5](https://user-images.githubusercontent.com/72328687/225626542-6de0434a-1f1e-424d-883d-8c5450a6f74d.png)

## 또 다른 결합 분리 모드

- **프로그래밍 언어가 제공하는 방법 외에도 소스 코드 의존성을 분리하는 방법은 존재할 수 있다.**
  - e.g. OSGi 같은 `모듈 프레임워크`나 자바 9에서 제공하는 새로운 `모듈 시스템`
- 다른 선택지로는 `소스 코드 수준에서 의존성을 분리하는 방법`이 있다.
  - 정확하게는 서로 다른 소스 코드 트리로 분리하는 방법이다.
  - `Maven`, `Gradle` 등 빌드 도구를 사용해 모듈이나 프로젝트가 서로 분리되도록 한다.
- 이러한 접근법은 소스 코드를 조직화할 때 효과가 있겠지만 잠재적으로 절충해야하는 부분이 있음을 알고 있어야만 한다.
  - 이 경우 특정 영역에 있는 인프라 코드(controller)가 애플리케이션의 다른 영역(repository)에 있는 코드를 도메인을 통하지 않고 호출할 수 있다.
  - 특히 해당 코드에 적절한 접근 지시자를 적용하는 걸 잊어버린 경우라면 이러한 호출을 막기는 더 힘들다.

## 결론

- 이 장에서는 최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다는 사실을 강조하는데 목적이 있다.
- 설계를 어떻게 해야만
  - 원하는 코드 구조로 매핑할 수 있을지
  - 그 코드를 어떻게 조직화할지
  - 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 고민하라!
- **그리고 가능하다면 선택사항을 열어두되, 실용주의적으로 행하고 팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려하라**
- 또한 선택된 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지 고민하고
- 데이터 모델과 같은 다른 영역에 결합되지 않도록 주의해라. 구현 세부사항에는 항상 문제가 있기 마련이다.
