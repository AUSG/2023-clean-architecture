## 31장) 웹은 세부사항이다

웹 등 GUI는 세부사항이다. 핵심 업무 로직에서 분리하여 경계 바깥에 두어야 한다.

- 애플리케이션과 GUI의 상호작용은 빈번하고, 상호 작용 방식 또한 사용 중인 GUI 종류에 따라 큰 차이가 있다.
- 유스케이스는 입력 데이터/업무 로직 처리/출력 데이터 를 기준으로 얘기할 수 있다.
    - 입력 데이터가 있을 때, 출력 데이터 구조를 만들어서 처리할 수 있게 업무 로직이 만들어져있다면 
    → UI는 입출력을 책임지고 있는 장치로 독립적으로 동작한다고 볼 수 있을 것이다.
- GUI 추상화는 제대로 만들기 어렵고 수차례의 반복 과정을 거쳐야 하지만 가능하다. 그리고 수차례의 반복을 통해서라도 해야한다.

## 32장) 프레임워크는 세부사항이다

- 프레임워크 제작다들은 당신을 모르고, 당신이 풀어야 할 문제도 알지 못한다.
    - 비슷한 문제를 해결하기 위해 나왔기 때문에 문제가 많이 겹치지만, 직접적으로 맞춤해서 만든 것은 아니다.
- 프레임워크 제작자는 프레임워크와 강하게 결합될 것을 요구한다.
    - 우리에겐 훗날 위험요소가 될 수 있다. / 프레임워크 제작자는 위험 요소가 아니다. 더 많이 검증되고 사용된 프레임워크가 될 뿐
- 프레임워크가 한번 원 안으로 들어가면, 바깥으로 꺼내는 것은 너무 어려운 일이다.
    - 제품이 성숙할 수록, 프레임워크에 기능과 툴에 벗어나야 하는 때가 올 것이다.
    - 새롭고 더 나은 프레임워크가 나와 갈아타고 싶더라도, 분리하기가 어려울 것이다.

### 해결책

- 프레임워크를 사용해라, 프레임워크에 의해 사용되지 말아라/종속 되지 말아라.
- 비지니스 로직 객체를 만들 때, 프레임워크의 기반 클래스를 의존하거나 파생하지 말아야 한다.
    - proxy를 만들어서 우회하든, 프레임워크의 핵심 코드/의존성이 우리 핵심 코드에 들어와서는 안된다.
- 메인에서 프레임워크를 조립하고, 다뤄야한다. (메인도 최저 수준의 컴포넌트기 때문)

## 33장) 사례 연구: 비디오 판매

- 아키텍처 설계
    - 액터와 유스케이스를 식별해야한다.
        - 주요 액터를 분리하면 나면 액터는 시스템이 변경되어야 할 주요 근원이 된다. → 단일 책임 원칙에 따라
        - 특정 액터를 위한 변경이 나머지 액터에게는 영향을 미치지 않게 해야한다.
    - 의존성 관리
        - 제어 흐름과 상관 없이, 의존성 규칙을 준수하게 설계하면 된다.

## 34장) 빠져 있는 장 (기존 저자가 쓴 글이 아닌, 시몬 브라운 기고 글)

1. 계층 기반 패키지
    1. 가장 단순하고 전통적인 수평 계층형 아키텍처
    2. 기술적인 관점에서 하는 일에 기반해 코드 분할 → 웹/비지니스 로직/영속성 분리
    3. 시작하기에 좋고, 복잡함을 겪지 않아도 무언가 작동시켜주는 아주 빠른 방법 → 하지만 소프트웨어가 커지면 곧 모든 코드를 담기에 부족하다고 느낄 것이다.
    4. 계층형 아키텍터는 모든 코드를 계층으로 나눠놓고 보면, 서로 다른 업무 도메인이라도 비슷하게 보인다. → 어떤 도메인을 다루고 있는지 보이지 않는 아키텍처가 된다.

1. 기능 기반 패키지
    1. 서로 연관된 기능/ 도매인 개념에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
    2. 패키지 이름을 개념을 반영해 작성하고, 해당 패키지 안에 코드를 다 몰아 놓는다. → 상위 수준 구조/패키지만 보더라도 어떤 도메인을 다루고 있는지 알 수 있다.
        1. 우리의 코드가 웹/서비스/레포지토리가 아니라 주문, 거래 도메인이라는걸 보여줄 수 있다.
        2. 주문 조회하기에 유스케이스가 변경 될 경우, 변경해야할 코드를 찾기 매우 쉽다. → 계층형에서는 저 멀리 왔다 갔다 해야만 했다.
    3. 많은 팀이 계층 기반에서 기능 기반으로 패키지를 전환한다. 하지만 차선택이다. 더 좋은 방법이 있다는 것을 우리도 알고 있다.

1. 포트와 어댑터
    1. 포트와 어댑터/육각형 아키텍처를 만들어 외부 인프라 코드와 내부 도메인 코드를 분리하는 방식
    2. 내부 영역은 도메인 개념, 외부 영역은 UI, DB, 서드 파티 등 외부 세계와의 상호작용
    3. **외부가 내부를 의존해야하고 내부는 외부를 의존해서는 안된다.!!!**
    4. 내부에 존재하는 것 들은 도메인 언어 관점에서 기술 해야한다.
        1. AllOrders: O
        2. JpaOrderRepository : X

1. 컴포넌트 기반 패키지
    1. 컴포넌트를 배포 단위가 아니라 연관된 기능들의 묶음으로 생각한다면 컴포넌트 기반으로 묶어서 만들 수 있다.
    2. 내부에서 관심사의 분리는 여전히 유효해야한다. (업무 로직/데이터 영속성은 분리해아한다.)
        1. 하지만 사용자는 관심이 없다. → 마이크로 서비스나 서비스 지향 아키텍처를 적용 했을 때의 얻는 이점과 유사하다.
        2. 모노리틱 애플리케이션에서 컴포넌트를 잘 정의하고 사용하면 마이크로 서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.

1. 구현 세부사항엔 항상 문제가 있다.
    1. 우리는 public 지시자를 고민 없이 본능적으로 사용하고 있다. → 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는 뜻이다.
    2. 이로 인해 누군가 구체적인 구현 클래스 인스턴스를 직접 생사하는 것도 우리는 막을 수 없게된다. → 지향아는 아키텍처 스타일이 어디서 깨지고 있을지 모른다.

1. 조직화 vs 캡슐화
    1. 모든 타입을 public으로 열어둔다면 패키지는 단순히 조직화를 위한 매커니즘에 불과하다.
    2. 외부에 공개할 것과 공개하지 않은 것을 분리하고 접근 지시자를 통해 캡슐화/은닉 해야만 패키지를 유의미하게 사용한 것이다.
        1. 모두 public이라면 사실 모든 아키텍처 접근법이 본질적으로 같아진다.
    3. 모든 코드가 하나의 소드 코드 트리에 존재하는 경우, 컴파일 후처리 도구/자기 규율을 사용하지 말고 컴파일러를 의지해보자.
    4. 언어가 제공하는 기능 외 소스 코드 의존성 분리 방법
        1. 자바에 OSGI 같은 모듈 프레임워크, 자바 9에서 제공하는 새로운 모듈 시스템

### 결론

최적의 설계를 꾀했더라도 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.

- 설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지, 어떻게 조직활할지, 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 항상 고민하라
- 선택사항을 열어두고, 최대한 늦게 결정하고 실용적으로 행동하자 (팀의 상황, 도메인의 복잡성, 일정, 예산을 모두 고려해야한다.)
- 선택한 아키텍터를 강제하는 데 컴파일러의 도움을 받을 수 있는지 고민하자
