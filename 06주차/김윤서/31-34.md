# 31장. 웹은 세부사항이다

### 끝없이 반복하는 추
지금까지 '모든 연산 능력을 중앙 서버에 두는 방식'과 '모든 연산 능력을 단말에 두는 방식' 사이에서 끊임없이 움직여 왔다.
웹 또한 이러한 진동을 겪고 있다.    
연산능력의 위치는 아래와 같이 반복된다.    
서버 팜(server farm) → 브라우저에 애플릿 추가 → 동적처리 서버로 이동 → 웹 2.0 고안, 브라우저에 Ajax와 자바스크립트 추가. → 현재는 거대한 애플리케이션 전부를 브라우저에서 실행되도록 작성가능. → Node.js를 이용해 자바스크립트를 다시 서버로 이동

### 요약
GUI는 세부사항이며, 웹은 GUI이다. 따라서 웹은 세부사항이다.
따라서 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.

- - - 

# 32장. 프레임워크는 세부사항이다.

### 프레임워크 제작자
프레임워크 제작자는 나를 위해서가 아니라 자신이나 자신의 동료와 친구들의 문제를 해결하기 위해 프레임워크를 제작한다.

### 혼인 관계의 비대칭성
나는 프레임워크를 위해 헌신해야 하지만, 프레임워크 제작자는 나를 위해 헌신하지 않는다.
대개의 경우 프레임워크 제작자들은 나의 애플리케이션이 가능하면 프레임워크에 공고하게 결합될 것을 강하게 역설한다.

### 위험요인
이러한 프레임워크 특성의 위험요인은 무엇인가?     
프레임워크 아키텍처가 그다지 깔끔하지 않을 수 있다.   
프레임워크는 의존성 규칙을 위반하는 경향이 있다. 프레임워크 객체 상속시 영원히 묶여 버리게 되어 헤어나오지 못할 수 있다.   
애플리케이션 초반에는 도움이 되겠지만 시간이 지나면서 제품은 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것이다.
프레임워크는 나에게 도움되지 않는 방향으로 진화할 수도 있다.   
신규 버전이 다른 일을 못하게 할 수도 있다.       
새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다.    

### 해결책
"프레임워크와 결혼하지 말라!"
프레임워크를 아키텍처 바깥 원에 속하는 세부사항으로 취급하여 원 안으로 들어오지 못하게 하라!
업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면 거절하고, 대신 프락시를 만들어 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 프락시를 위치시켜라.
예를 들어 Spring 사용시, 업무 객체보다는 메인 컴포넌트에서 스프링을 사용해서 의존성을 주입하는 편이 낫다.(Spring은 의존성 주입 프레임워크)
프레임워크가 핵심 코드 안으로 들어오지 못하게 하라.
대신 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수하라.

### 결론
정말 결혼해야 하는 프레임워크도 있다. 그러나 선택적이어야 한다.   
프레임워크를 사용한다는 뜻은 애플리케이션이 프레임워크와 결혼한다는 의미이기 때문에 신중하게 선택해야 한다.

- - - 

# 33장. 사례연구: 비디오 판매

사례를 통해 지금까지 살펴 보았던 아키텍처에 대한 규칙과 견해를 종합적으로 살펴본다.   
뛰어난 아키텍트가 일을 처리하는 과정과 결정을 내리는 모습을 볼 수 있다.   

서비스를 이해하고 초기 아키텍처를 결정하기 위해 액터와 유스케이스를 식별한다.
그리고 이 식별된 정보를 가지고 특정 택어를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 할 수 있도록 시스템을 분할한다.
유스케이스 중에 일부 겹치는 경우가 있을텐데 이는 추상 유스케이스 로 분류하여 추상화할 수 있다.
사실 이 추상 유스케이스가 없더라도 문제는 없고 이 추상화를 꼭 생성해야만 하는 것은 아니었으나 여기서는 유사성을 식별해 분석 초기에 통합하는 방법을 찾는 편이 더 현명하다고 판단한다.


### 컴포넌트 아키텍처
액터와 유스케이스를 식별하면 아래와 같이 예비 단계의 컴포넌트 아키텍처를 구성해볼 수 있다.
각각 View, Presenter, Interactor, Controller 로 분리된 전형적인 분할 방법을 확인할 수 있고 각 액터에 따라 카테고리를 분리한 것을 알 수 있다.
그리고 중간에 Catalog View, Catalog Presenter 는 추상 클래스로 생성될 것이다.

![image](https://user-images.githubusercontent.com/61778930/226118427-56ea0c7d-0bb6-4c83-bfe0-54ea965b9334.png)


### 의존성 관리
위 컴포넌트 아키텍처를 살펴보면 의존성 규칙을 준수하고 의존성(제어흐름)이 단방향으로 흐른다는 것을 알 수 있다.   
항상 의존성이 올바른 방향으로 흐르게하고 저수준의 세부사항에서 발생한 변경이 상위로 파급되어서 상위 수준의 정책에 영향을 미치지 않음을 보장하자.

- - - 

# 34장. 빠져 있는 장

이 장에서는 클린 아키텍처를 실전에 도입시(코드화) 맞닥트릴 문제점과 해결책에 대해 설명한다.
따라서 클린 아키텍처는 잠시 한쪽으로 제쳐 놓고, 설계나 코드 조직화와 관련된 몇 가지 접근법을 살펴보자.

### 계층 기반 패키지
- 전형적인 계층형 아키텍처는 웹, 업무규칙, 영속성 코드를 위해 수평으로 계층을 나눈다.
- 엄격한 계층형 아키텍처라면 계층은 반드시 아래 게층에만 의존해야 한다.
- 계층형 아키텍처는 처음 시작 프로젝트를 시작히기엔 큰 문제가 없지만 시간이 지나면서 업무 도메인에 대해 알수 없다는 문제점이 드러나게 된다. (단순히 웹 - 업무규칙 - 영속성 코드로만 패키지화 되어 있기 때문, 만약 새로운 유스케이스를 추가하거나 기존의 것을 수정해야 될 때 어디서 시작해야할지 찾기 어려워짐.)

![image](https://user-images.githubusercontent.com/61778930/226118549-9fceda5c-e38f-49a2-b6d3-85755a659dab.png)

### 기능 기반 패키지
- 서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식.
- 계층 기반 패키지와 달리 단 하나의 패키지로 묶여 있다. → 주문과 관련된 도메인이라는 점을 쉽게 파악할 수 있다. 또한 '주문 조회하기' 유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워짐.
- 서비스가 복잡해질수록 계층기반 패키지에서 기능기반 패키지로 리팩토링 하는 경향이 많지만 이는 좋은 코드 조직화 관점에서 보자면 차선책에 불과하다.

![image](https://user-images.githubusercontent.com/61778930/226118595-a20bc457-d901-4ac3-a4ac-c75fca33f93b.png)

### 컴포넌트 기반 패키지
SOLID, REP, CCP, CRP에 대해 동감하지만, 코드를 조직화하는 방법에 대해 다른 결론에 이름. 그래서 또 다른 선택지를 제시하려고 하는데 이를 '컴포넌트 기반 패키지'라고 부름.

컴포넌트 기반 패키지를 살펴보기 앞서 계층형 아키텍처 문제점을 살펴보자.

#### 계층형 아키텍처

계층형 아키텍처는 의존성 화살표가 항상 아래로 향해야하고 각 계층은 반드시 바로 아래 계층에만 의존해야 함.   
이런 방식으로 깔끔한 비순환 의존성 그래프를 만들 수 있지만 코드베이스의 요소들이 서로 의존할 때는 몇가지 규칙을 반드시 지켜야함.
계층형 아키텍처를 비순환 의존성 그래프 형식으로 만들 수 있지만 문제는 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도 보기에는 여전히 좋은 비순환 의존성 그래프가 생긴다.

#### 신입사원의 완화된 계층형 아키텍처 예시.
OrdersController가 OrdersRepository로 아래로 의존하기 때문에 비순환 원칙을 어기진 않는다. 그렇지만 이는 원하는 흐름이 아니다. 웹은 반드시 업무규칙와 분리되어야 하는데, 그러지 못하고 있기 때문에 잘못된 것이며 반드시 강제하는 규칙을 팀 내에서 정해야 한다. 하지만 이는 사람에게 강제하는 규칙이기 때문에 상황에 따라 위반되는 경우들이 많이 발생한다..
포트 어댑터에서 웹을 그저 또 다른 전달 메커니즘으로 취급하는 것과 마찬가지로, 컴포넌트 기반 패키지에서도 사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지한다.

이 접근법은 '업무 로직'과 영속성 관련 코드를 하나로 묶는다.
컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직 OrdersComponent만 둘러보면 된다.
이 컴포넌트 내부에서 관심사의 분리는 여전히 유효하며 따라서 업무 로직은 데이터 영속성과 분리되어 있다.

## 구현 세부사항엔 항상 문제가 있다
살펴본 네 가지 아키텍처를 구현시 public 지시자를 과용한다면 설계 의도에 부합하는 아키텍처 스타일을 만들 수 없다.

### 조직화 vs. 캡슐화
모든 타입을 public으로 지정한다면 패키지는 단순히 조직화를 위한 메커니즘(폴더와 같이 무언가를 묶는 방식)으로 전락하여 캡슐화를 위한 메커니즘이 될 수 없다.   
public 지시자를 과용하면 네 가지 아키텍처 접근법은 본질적으로 같아진다.   

- 채택하려는 아키텍처 접근법과 관계 없이 화살표들이 모두 동일한 방향을 가리키고 있다.
- 모든 타입을 public으로 선언한다면 수평적 계층형 아키텍처를 표방하는 네 가지 방식에 지나지 않는다.
