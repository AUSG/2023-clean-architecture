# 31장~34장

# 31장 웹은 세부사항이다

### 끝없이 반복하는 추

- 연산 능력을 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다
- 업무규칙을 UI로부터 분리했어야 한다

### 요약

- GUI는 세부사항이고 웹은 GUI다 - 웹은 세부사항이다 → 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다
- 웹은 입출력 장치다 - 장치 독립적으로 만들어야 했던 동기 자체는 지금도 유효하고, 웹도 이 규칙에서 예외가 될 수 없다
- js의 유효성 검증 등을 보았을 때 웹에서 장치 독립성은 비현실적이라고 주장하기 쉽다
    - 브라우저와 웹 어플리케이션이 함께 추는 춤은 데스크톱 GUI와 데스크톱 애플리케이션이 함께 추는 춤과는 차이가 난다
    - 그러나 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다 → 업루 로직은 다수의 유스케이스로 구성, 각 유스케이스는 사용자를 대신해 일부 함수를 수행하는 것으로 볼 수 있음
    - 완전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있음 → 이 방식을 따르면 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주할 수 있다

### 결론

- 이런 종류의 추상화는 어렵지만 가능함, 꼭 필요할 때가 많음

# 32장 프레임워크는 세부사항이다

- 아무리 해도 프레임워크는 아키텍처가 될 수 없다

### 프레임워크 제작자

- 프레임워크 제작자는 자신이 해결해야 할 고유한 문제나 자신의 동료와 친구들의 문제를 알고 있기 때문에 그걸 해결하려고 만들지만, 당신의 문제를 해결하기 위해서가 아니다
- 겹치는 문제가 많을수록 유용할 것

### 혼인 관계의 비대칭성

- 당신은 헌신해야하지만, 프레임워크 제작자는 아무런 헌신도 하지 않는다
- 사실상 제작자는 당신이 프레임워크에 결합되길 바람 - 그 관계를 깨기 어렵도록

### 위험요인

- 프레임워크 아키텍처는 그다지 깔끔하지 않은 경우가 많다
- 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것
- 프레임워크는 당신에게 도움되지 않는 방향으로 진화할 수 있다
- 새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다

### 해결책

- 프레임워크와 결혼하지 말라!
- 업무 객체를 만들 때 프레임 워크가 자신의 기반 클래스로부터 파생하기를 요구한다면 거절하고, 프록시를 만들어 업무 규칙에 플러그인 할 수 있는 컴포넌트에 프레임워크를 통합하고 의존성 규칙을 준수해라
- 업무 객체보다는 메인 컴포넌트에서 스프링을 사용하여 의존성을 주입하는 편이 낫다 - 메인은 아키텍처 내에서 가장 지저분한 최저 수준의 컴포넌트이기 때문에 스프링을 알아도 상관 없다

### 이제 선언합니다

- 애플리케이션이 프레임워크와 결혼하고자 한다면 애플리케이션의 남은 생애 동안 그 프레임워크와 항상 함께 해야한다는 사실을 반드시 명심해야 한다.

### 결론

- 프레임워크와의 첫만남부터 바로 결혼하려 들지 말라. 가능한 오랫동안 프레임워크를 아키텍처 경계 너머에 두자

# 33장 사례연구 : 비디오 판매

### 제품

- 아키텍처를 적용해볼 사례로 소프트웨어 튜토리얼 비디오를 판매하는 소프트웨어 제품
- 시스템의 초기 아키텍처를 결정짓는 첫 단계는 액터와 유스케이스를 식별하는 것

### 유스케이스 분석

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled.png)

- 네 가지 주요 액터는 분명하고, 단일 책임 원칙에 따르면 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원이 됨
    - 특정 액터의 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 해야함.
- 중앙 점섬으로된 유스케이스는 추상유스케이스임 → 이는 범용적인 정책을 담고있으며 다른 유스케이스에서 이를 더 구체화시킴.
- 시청자, 구매자입장에서 카탈로그 조회하기는 추상 카탈로그 조회하기 유스케이스를 상속함 → 추상 유스케이스는 저자만의 방법임, <<abstract>> UML 스테레오타입을 사용해도 무난

### 컴포넌트 아키텍처

- 유스케이스 식별 후 예비단계 컴포넌트 아키텍처를 만들어 볼 수 있음

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%201.png)

- 특수한 컴포넌트인 Catalog View와 Catalog Presenter는 해당 컴포넌트 내부에 추상클래스로 코드화되며 이를 상속받는 컴포넌트는 추상클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함함.
- 각 컴포넌트는 단일 .jar에 해당할 수 있지만 경계를 구분해서 뷰, 프레젠터, 인터렉트, 컨트롤러, 유틸리티 각각을 하나의 jar로 구분할 수 있음. 또한 뷰와 프레젠터를 같은 .jar에 두고 나머지는 개별로 둘 수 있으며 이처럼 각 컴포넌트들이 독립적으로 컴파일하고 빌드할 수 있는 환경으로 구성되게끔 선택지를 열어두면 시스템이 변경되는 양상에 맞춰 배포방식을 조절할 수 있음.

### 의존성 관리

- 입력이 컨트롤러에서 발생되면 인터랙터에 의해 처리되며 프레젠터가 결과의 포맷을 변경하고 뷰가 화면에 표시됨.
    - 아키텍처가 의존성 규칙을 준수하기 때문에 모든 의존성은 항상 더 높은 수준의 정책을 포함하는 컴포넌트로 향함.
    - 사용관계(색칠된화살표)는 제어흐름과 같은방향을 가리키며 상속관계(색칠되지 않은 화살표)는 제어흐름과는 반대 방향을 가리킴. - 개방 폐쇄 원칙, 의존성이 올바른 방향으로 흐르며 저수준 세부사항에서 발생한 변경이 상위로 파급 되지 않음을 보장 가능

### 결론

- 위 33.2의 아키텍처 다이어그램은 서로 다른 차원의 분리 개념을 포함하고 있음 - 단일 책임 원칙에 기반한 액터의 분리, 의존성 규칙
    
    → 이런 방식으로 코드를 구조화 하면 시스템을 실제로 배포하는 방식을 다양하게 선택가능함.
    

# 34장 빠져있는 장

- 온라인 서점 구축, 고객이 주문 상태를 조회할 수 있어야 한다는 유스케이스를 구현한다고 가정

### 계층 기반 패키지

- 해당 코드가 하는 일에 기반해 그 코드를 분할, 전통적인 수평 계층형 아키텍처
- 전형적인 계층형 아키텍처에는 웹, 업무규칙, 영속성 코드를 위해 계층이 하나씩 존재함
    - 코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용됨
    - 엄격한 계층형 아키텍처의 경우 계층은 반드시 아래 계층에만 의존해야 함
- 이러한 계층형 아키텍처는 복잡함을 겪지않고 무언가를 작동시켜주지만 업무 도메인에 대해 아무것도 말해주지 않음.
    - 전혀 다른 업무도메인이라도 코드를 계층형 아케턱쳐로 만들어 나란히 놓고보면 웹, 서비스, 레파지토리로 구성된 모습이 비슷하게 보이기 때문

### 기능 기반 패키지

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%202.png)

- 서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
- 계층기반패키지와 인터페이스와 클래스는 이전과 같지만 모두가 order라는 단 하나의 패키지에 속하게 됨.
    - 상위 수준 구조가 업무 도메인에 대해 무엇인가를 알려주게됨.
    - 또한 '주문 조회하기' 유스케이스가 변경될 경우 order라는 한 패키지만 찾으면되기 때문에 수월해짐.
- 계층 기반, 기능기반 둘 다 차선책임

### 포트와 어댑터

- 육각형 아키텍처 혹은 포트와 어댑터방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 프레임워크나 DB같은 세부사항에서 독립적이며 분리된 아키텍처를 만들기 위함임

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%203.png)

- 외부가 내부를 의존하며 절대 그 반대는 되면 안됨.

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%204.png)

- com.mycompany.myapp.domain 패키지가 '내부' 도메인 이며 나머지 패키지는 '외부'임.
- 추가로 Orders는 OrdersRepository라는 이름에서 바뀐 이름인데 도메인주도설계에서 유비쿼터스 도메인 언어를 관점으로 기술하라고 했기때문에 반영된 것
    - 예를 들면 도메인에 대해 논의할 때 '주문'에 대해 말하는것이지 '주문 레파지토리'에 대해 말하는것이 아니기 때문임.

### 컴포넌트 기반 패키지

- SOLID, REP, CCP, CRP 등 이 책에서 나온 여러 조언을 저자는 전적으로 동의하지만 '컴포넌트 기반 패키지'또 다른 선택지를 제시함.
- 계층형 아키텍처에서 아래 계층에만 의존하여 깔끔한 비순환 의존성 그래프를 만들 수 있지만 코드베이스의 요소들이 서로 의존할 때는 몇가지 규칙을 반드시 지켜야함.
    - 그러나 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도 여전히 좋은 비순환 의존성 그래프가 완성됨.

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%205.png)

→ 여전히 의존성 화살표는 아래를 향하고 있지만 개별 레코드에 대해 인증된 접근만을 허용하는 일을 업무 로직이 책임지는 경우 바람직하지 못함.

→ 추가로 컨트롤러가 업무규칙을 포함하게되기 때문에 더더욱 올바르지 못함. 여기서 필요한 지침은 "웹 컨트롤러는 절대로 레파지토리에 직접 접근해서는 안 된다" 임.  → 적은 수의 팀만이 정적 분석 도구를 사용해 그런 것들을 강제한다고 함 

- 컴포넌트 기반 패키지라는 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라보며, 마이크로서비스 아키텍처가 가진 시각과도 동일함.
- 컴포넌트 기반 패키지 접근법은 주문과 관련된 무언가를 코딩할 때 오로지 한 컴포넌트만 보면됨
    - 컴포넌트 내부에서 관심사의 분리는 유효하며 업무로직은 데이터 영속성과 분리되어 있음, 그러나 사용자는 알 필요 없음(컴포넌트 구현 세부사항이므로)

### 구현 세부사항엔 항상 문제가 있다

- 앞서 말한 네가지 접근법이 코드를 조직화하는 서로다른 아키텍처 스타일로 여겨질 수 있지만 세부사항을 잘못 구현하면 이런 견해도 빠르게 흐트러짐.
    - 자바같은 언어에서 public을 지나칠 정도로 방만하게 사용함. 모든 타입에서 public 지시자를 사용한다는것은 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는것임.
    - 이로 인해 누군가가 구체적인 구현 클래스의 인스턴스를 직접 생성하여 본인이 지향하는 아키텍처 스타일을 위한하게 될 수 있음.

### 조직화 vs 캡슐화

- 자바 애플리케이션에서 모든 타입을 public으로 지정한다면, 패키지는 단순히 조직화를 위한 매커니즘(폴더구조)으로 전략하여 캡슐화를 위한 메커니즘이 될수 없음→ public 지시자를 과용하면 이 장의 앞에서 제시한 네 가지 아키텍처 접근법은 본질적으로 같아짐.

![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%206.png)

- 계층 기반 패키지, 기능 기반 패키지, 포트와 어댑터, 컴포넌트 기반 패키지 순
- 더 제한적인 접근 지시자를 사용하는 타입은 흐리게 표현됨.
- 계층 기반 패키지 : 구현체 클래스는 더 제한적으로 선언 가능
- 기능 기반 패키지 : OrdersController가 패키지로 들어올 수 있는 유일한 통로 제공하므로 나머지는 모ㅜ 패키지 protected로 지정할 수 있음
- 포트와 어댑터 : 구현 클래스는 패키지 protected로 지정하며 런타임에 의존성 주입 가능
- 컴포넌트 기반 패키지 : 컨트롤러에서 Orders컴포넌트 인터페이스로 향하는 의존성을 갖는데 그 외의 것은 모두 패키지 protected로 지정 가능

### 다른 결합 분리 모드

- 소스코드 의존성 분리는 프로그래밍언어가 제공하는 방법 외에도 자바 OSGi나 자바9에서제공하는 모듈 시스템으로 분리할 수 있음.
- 다른 선택지로는 소스코드 수준에서 의존성을 분리하는 방법임.
    - 포트와 어댑터로 예로들면
        - 업무와 도메인용 소스 코드: OrderSerivce, OrdersServiceImpl, Orders
        - 웹용 소스 코드: OrdersController
        - 데이터 영속성용 소스 코드: JdbcOrderRepository
        
        → 마지막 두 소스 트리는 컴파일 시점에서 업무와 도메인용 소스코드에 의존성을 가지며 업무와 도메인용 소스코드는 웹, 데이터영속성 코드에 대해 알지 못함.
        
        → 너무 이상적인 해결책
        
- 소스 코드 트리를 두 개만 만드는 해결책
    
    ![Untitled](31%E1%84%8C%E1%85%A1%E1%86%BC~34%E1%84%8C%E1%85%A1%E1%86%BC%2052dc5224ffc04a3bb6195097de48300f/Untitled%207.png)
    
    - 도메인 코드(내부) / 인프라 코드 (외부)
        - 소스코드 조직화할 때 효과 있지만 잠재적으로 절충해야할 부분 있음
        - 포트와 어댑터에 대한 페리페리크(프랑스에있는 원형 순환도로로써 북적대는 파리시내에 진입하지 않고도 파리 전체를 둘러볼 수 있음) 안티 패턴 → 즉, 특정영역(인프라코드중 웹 컨트롤러 부분)이 애플리케이션의 다른 영역에 있는 코드를 도메인 코드를 통하지않고 직접 호출할 수 있음.

### 결론: 빠져 있는 조언

- 설계를 어떻게 해야 원하는 코드 구조로 매핑할 수 있을지, 그 코드를 어떻게 조직화할지, 런타임과 ㅋㅁ파일 타임에 어떤 결합 분리 모드를 적용할지 고민하라
- 팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려하라
- 선택된 아키텍처 스타일을 강제하는데 컴파일러의 도움을 받을 수 있을지 고민하라