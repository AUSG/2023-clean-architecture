# 31. 웹은 세부사항이다

-   어플리케이션을 보호하기 위해선 업무 규칙을 UI와 분리해야한다.

-   GUI는 세부사항이며, 웹은 세부사항이다.
-   웹은 입출력 장치이며, 장치 독립적으로 만들어야했던 동기 자체는 아직도 유효하다. 웹에도 예외는 없다.



# 32. 프레임워크는 세부사항이다

-   프레임워크는 아키텍쳐가 될 수 없다.

    

## 프레임워크 제작자

-   프레임워크 제작자는 자신이 불편한 점을 해소하기 위해 개발하고 공개한다.
-   하지만, 프레임워크 제작자와 불편한점이 동일할 수 없다.



## 혼인 관계의 비대칭성

-   프레임워크 제작자는 프레임워크와 결합하기를 원한다.
-   프레임워크 제작자가 제어권을 지고 있기에, 프레임워크 제작자는 위험이 없다.
-   하지만, 사용자는 한 번 결합하면 변경이 어렵고 헌신해야하는 비대칭적인 혼인관계를 맺게 된다.



## 위험 요인

-   프레임워크는 의존성 규칙을 위반하는 경우가 있다.
-   제품이 성숙해지면, 프레임워크가 제공하는 기능에서 벗어나야할 때가 있다. 그런데, 결혼했다면 그게 어려워진다.
-   프레임워크는 당신에게 도움되지 않는 방향으로 진화할 수 있다.
-   새롭고 더 나은 프레임워크로 갈아타고 싶을 수 있다.



## 해결책

-   프레임워크와 결혼하지 말라!
-   업무 규칙에 플러그인할 수있는 컴포넌트에 프락시를 위치시켜라.
-   스프링 사용시 `@Autowired` 를 사용하지 말고, 메인에서 직접 조립해라.



## 이제 선언합니다

-   표준 라이브러리와 결혼하는 것은 피하기 힘들다. 하지만 선택적으로 사용하라.



# 결론

-   프레임워크와 바로 결혼하지 말라. 연애를 오랫동안 할 수 있는 방법이 있는지 확인해라.



# 33. 사례연구 : 비디오 판매

-   비디오 판매 사이트를 예시로 유스케이스와 컴포넌트 아키텍쳐를 설계하는 방법을 설명



## 유스케이스 분석

-   단일 책임 원칙에 따라, 액터가 시스템이 변경되어야 할 근원이다.
-   액터와 유스케이스를 분석하고, 비슷한 유스케이스는 추상 유스케이스로 설정



## 컴포넌트 아키텍쳐

-   뷰, 프레젠터, 인터랙터, 컨트롤러로 분리.
-   추상 유스케이스는 추상 클래스가 되어, 추상클래스로 부터 상속한 뷰와 프레젠터를 포함.



## 의존성 관리

-   의존성 규칙을 준수하고, 의존성이 단방향으로 흐르도록 관리
-   의존성이 올바른 방향을 가리키게하여, 저수준의 변경이 고수준의 정책에 영향을 끼치지 않도록하자.



# 34. 빠져있는 장

-   클린 아키텍쳐를 잠시 제쳐두고, 설계와 코드 조직화를 알아보자.



## 계층 기반 패키지

-   코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용된다.
    -   엄격한 계층형 아키텍쳐는 반드시 바로 아래 계층에만 의존해야한다.
-   이 계층형 기반은 복잡함 없이 빠르게 무언가를 작동시킬 수 있지만, 추후에는 더 잘게 모듈화해야하는지에 대해 고민하게 될 것이다.

-   또한, 계층형 아키텍처는 업무 도메인에 대해 아무 것도 말해주지 않는다.



## 기능 기반 패키지

-   서로 연관된 기능, 도메인 개념 또는 Aggreate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.
-   코드의 상위 수준 구조가 도메인에 대해 알려주고, 유스케이스를 변경해야 할 경우 모두 찾는 작업이 쉬워질 수 있다.
-   계층 기반 보다는 낫지만, 차선책이다.



## 포트와 어댑터

-   포트와 어댑터 패턴에서는 기술의 세부 구현을 분리하기 위해, 내부 ( 도메인 ) - 외부 ( 인프라 ) 로 구성함.
-   도메인 주도 설계 관점에서는 내부에 속하는 것은 반드시 유비쿼터스 도메인 언어 관점에서 기술하도록 조언한다.
    -   우리는 주문에 대해 말하지, 주문 repository에 대해 말하지 않는다.



## 컴포넌트 기반 패키지

-   계층형 기반 패키지는 개발시 계층을 건너뛸 수 있다는 문제가 있음.
-   컴포넌트 기반 패키지는 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는데 주안점을 둔다.

-   컴포넌트는 "멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음"이다

    

## 구현 세부사항엔 문제가 있다

-   위 4가지 기반 패키지는 서로 다른 아키텍쳐 스타일로 여길 수 있지만, 접근 지시자등을 방만하게 사용할 경우 캡슐화등의 이점을 활용하지 못한다.



## 조직화 vs 캡슐화

-   public 으로만 사용하면, 사실 앞서 말한 4가지는 거의 같은 아키텍쳐나 다름이 없다.
-   각 아키텍쳐별로 어떻게 사용하면 좋을지 알아보자.

-   계층 기반 패키지
    -   구현체 클래스들은 더 제한적으로 선언하는 protected package와 같은 방식을 이용할 수 있다.
-   기능 기반 패키지
    -   Controller가 패키지로 들어올 수 있는 유일한 통로이므로, protected package로 지정할 수 있다.
-   포트와 어댑터
    -   인터페이스는 public으로, 구현 클래스는 protected packafge로 지정하여 런타임에 의존성을 주입할 수 있다.
-   컴포넌트 기반 패키지
    -   Component 인터페이스를 제외하고는 모두 protected로 선언할 수 있다.



## 다른 결합 분리 모드

-   프로그래밍 언어가 제공하는 방법 외에도 소스 코드 의존성을 분리하는 방법이 있음. ( 자바 OSIG.. )
-   소스코드 수준에서의 의존성 분리를 통해 도메인에서 다른 계층을 모르게하는 방법도 있음.
    -   하지만 이렇게 나누면 복잡성이 증가하기도 한다.
    -   이보다 간단한 방법으로, 내부 ( 도메인 ) - 외부 ( 인프라 ) 를 나누기도 하는데 이 접근법은 페리페리크 안티패턴이다.



## 결론 : 빠져 있는 조언

-   설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지, 어떻게 조직화할지, 런타임과 컴파일타임 중 언제 결합 분리 모드를 적용할지 고민하라
-   가능하다면 선택사항을 열어두되, 실용주의적으로 행하라
-   팀 규모, 기술 수준, 해결책의 복잡성을 일정 및 예산과 동시에 고려하라

