# 3부. 설계 원칙

SOLID 원칙은 함수와 데이터 구조를 **클래스**로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.    

SOLID 원칙의 목적은 중간 수준(모듈/컴포넌트 내부)의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.   

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용되는 컴포넌트의 기반이 된다.

### 📍 SOLID 원칙 개요

- [**SRP** (Single Responsibility Principle): 단일 책임 원칙](https://github.com/ottlseo/2023-clean-architecture/new/main/02%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%9C%A4%EC%84%9C#07%EC%9E%A5-srp-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)
    - 각 소프트웨어 모듈은 변경의 이유가 단 하나여야 한다.
- [**OCP** (Open-Closed Principle): 개방-폐쇄 원칙](https://github.com/ottlseo/2023-clean-architecture/new/main/02%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%9C%A4%EC%84%9C#08%EC%9E%A5-ocp-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99)
    - 시스템을 변경할 때, 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 변경할 수 있도록 설계해야 한다.
- [**LSP** (Liskov Substitution Principle): 리스코프 치환 원칙](https://github.com/ottlseo/2023-clean-architecture/new/main/02%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%9C%A4%EC%84%9C#09%EC%9E%A5-lsp-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99)
    - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
- [**ISP** (Interface Segregation Principle): 인터페이스 분리 원칙](https://github.com/ottlseo/2023-clean-architecture/new/main/02%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%9C%A4%EC%84%9C#10%EC%9E%A5-isp-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99)
    - 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
- [**DIP** (Dependency Inversion Principle): 의존성 역전 원칙](https://github.com/ottlseo/2023-clean-architecture/new/main/02%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%9C%A4%EC%84%9C#11%EC%9E%A5-dip-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99)
    - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

---

# 07장. SRP: 단일 책임 원칙

> 단일 모듈은 변경의 이유가 오직 하나뿐이어야 한다.
> 

→ 하나의 모듈은 오직 하나의 Actor에 대해서만 책임져야 한다.

→ 단일 액터를 책임지는 소스 코드들을 하나의 모듈로 묶어주는 힘이 ‘응집성’이다. 

SRP 원칙을 위반하는 징후를 알아보며 SRP를 이해해보자. 

## 징후 1. 우발적 중복

Ex) Employee 클래스는 calculatePay, reportHours, save 메소드를 가진다.

- calculatePay: 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용됨
- reportHours: 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용됨
- save: DBA가 기능을 정의하고, CTO 보고를 위해 사용됨

![image](https://user-images.githubusercontent.com/61778930/219889379-66bc0b42-dea5-47fa-b41e-71853222fa54.png)


문제는?

- Employee 클래스는 3가지 메소드가 서로 다른 3명의 액터를 책임지므로 SRP를 위반하고 있다.
- 이로 인해 CFO 팀에서 결정한 조치가 COO 팀의 의존하는 무언가에 영향을 줄 수 있다.
- 예를 들어, calculatePay와 reportHours 두 메소드에서 `regularHours`(업무 시간 계산) 메소드를 공통으로 사용하고 있다고 하자
    
    → CFO 팀에서 `regularHours`를 수정하면 COO 팀도 영향을 받게 된다. 
    

⇒ 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문이다. SRP는 서로 다른 액터가 의존하는 코드를 분리하라고 말한다. 
+ 코드 중복이 꼭 나쁜 것만은 아니다. 분리가 필요한 시점이 왔을 때 같은 코드라도 과감히 분리하는 것으로 SRP를 지킬 수 있다. 

## 징후 2. 병합 (Merge)

여러 사람이 하나의 코드를 수정할 경우 병합이 발생한다. 

하나의 소스 파일이 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 더욱 높다. 

→ 해결책: 서로 다른 액터를 뒷받침하는 코드라면 **서로 다른 클래스로 분리**하는 것이 좋다. 

- 여러 액터의 데이터와 메소드를 분리하는 방식. 간단한 데이터 구조만 공유하도록 한다.
- 세 클래스를 인스턴스화 하고 추적해야 하는 단점이 있으며, 이를 빠져나오기 위해 퍼사드(Facade) 패턴을 많이 사용한다.
    
    ![image](https://user-images.githubusercontent.com/61778930/219889458-9c726336-4ff9-40bd-a064-a224666b91e5.png)


### 결론.

SRP는 메서드와 클래스 수준의 원칙이다.    

하지만 이보다 상위의 모듈과 컴포넌트 수준에서도 OCP(공통 폐쇄 원칙)로 다시 등장한다.    

---

# 08장. OCP: 개방-폐쇄 원칙

- OCP는 “소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다”는 원칙.
- 행위를 확장할 수 있어야 하지만 개체를 변경해서는 안 된다. 이것이 아키텍처를 공부하는 근본적인 이유이다.

아래의 복잡한 아키텍처를 뜯어보며 OCP 원칙을 이해해보자.    

![image](https://user-images.githubusercontent.com/61778930/219889688-59347c89-7607-4130-aa77-799d684e8c7f.png)


- 위의 모든 의존성은 소스코드 의존성을 나타낸다.
- 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
    - ex) A를 변경할 때 B를 보호하려면 A가 B에 의존해야 한다. (A→B)

## 사고 실험

소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 최소화될 것이며, 이상적인 변경량은 0이다.    

→ 변경량을 최소화 하려면?    

- **서로 다른 목적으로 변경되는 요소를 적절히 분리**하고(SRP),
- 이들 사이 **의존성을 체계화**해야 한다(DIP).

위 아키텍처에는 어떤 의미가 있나?   

- 위 그림에서는 Presenter에서 발생한 변경으로부터 Controller를 지키고자 한다.
- Interactor는 어디에도 의존하지 않는다. (즉, Interactor는 다른 모든 것의 변경으로부터 보호 받는다)
- Interactor는 비즈니스 로직을 포함하는 컴포넌트로, OCP를 가장 잘 준수하도록 되어 있다.

## 방향성 제어

⇒ ***인터페이스의 용도는 의존성을 역전시키기 위함이다.***    

- 이중선 그림에서 Interactor와 Database 사이에 Financial DataGateway가 위치한 이유는 의존성을 역전시키기 위해서다.
- 인터페이스가 없다면 Interactor의 의존성이 Database를 향하게 된다.

## 정보 은닉

***⇒ 반대로 인터페이스는 의존성을 가진 클래스 간 정보를 보호하기 위해서도 사용된다.***    

- FinancialReportRequester는 방향성 제어를 위해서가 아니라, Controller가 Interactor 내부에 대해 너무 많이 알지 못하도록 하기 위해 존재한다.
- 만약 이 인터페이스가 없다면, Controller는 FinancialEntities에 대해 ‘추이 종속성’을 갖게 된다. (서로 의존하고 있는 개체들이 사이클을 이뤄 더한 종속이 이뤄지는 것)
- Controller의 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호되기 위해 Interactor 내부를 은닉한다.

### **결론.**

- OCP의 목표는 시스템을 확장하기 쉽게 하는 동시에, 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것이다.
- 이를 위해 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경으로부터 고수준 컴포넌트를 보호할 수 있는 구조가 되어야 한다.

---

# 09장. LSP: 리스코프 치환 원칙

- 하위 타입을 치환하더라도 모든 행위가 변하지 않아야 한다.
- Ex 1) License라는 Interface에는 2가지 타입이 있다고 할 때, License를 호출하는 Billing 애플리케이션은 License의 두 하위 타입을 신경쓰지 않아도 된다.
    
    → Billing 애플리케이션의 행위가 License 하위 타입에 **전혀 의존하지 않으므로** 하위 타입은 모두 License 타입을 **치환할 수 있다.**   
    
- Ex 2) 정사각형은 직사각형의 하위 타입이 아니다.
    
    → 직사각형의 높이와 너비는 서로 독립적으로 변경될 수 있지만, 정사각형은 높이와 너비가 반드시 함께 변경되어야 한다는 제약이 있다.    
    
    이를 LSP에 맞게 사용하기 위해서는 정사각형인지 아닌지 판단하는 메커니즘을 추가해야 한다.    
    

## LSP 위배 사례

Ex) 택시 파견 서비스를 통합하는 애플리케이션을 만드는 상황일 때,   

- A 택시 회사의 택시 파견 서비스를 이미 구현한 상황 (URI: `/destination`)
- 새로운 팀이 B 택시 회사 파견 API를 일부 다르게 설계 (URI: `/dest`)
- REST 서비스들이 서로 호환되지 않아 오류가 발생하고, 이를 해결하기 위해 if 문으로 A 회사인지 B 회사인지를 핸들링하는 로직을 추가한다. ⇒ **LSP 위배**
- 아키텍처에서는 if로 분기 처리가 아니라, 치환되지 않는 REST 서비스들의 인터페이스를 처리하는 매커니즘이 필요하다.

### 결론.

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
- LSP를 조금이라도 위배하면 시스템 아키텍처가 오염되어, 상당량의 if문과 같은 별도 매커니즘을 추가해야 할 수 있다.

---

# 10장. ISP: 인터페이스 분리 원칙

- 사용하지 않는 것에 의존하지 않아야 한다.
    - 의존하는 컴포넌트, 클래스도 최소 단위로 나눠야 한다.
- 각각의 기능을 인터페이스로 분리함으로써, 사용하는 기능의 인터페이스만 의존하여 의존성을 분리할 수 있다.
- 결합도가 낮은 시스템을 만들 수 있다. → 단일 모듈 배포/컴파일이 가능해진다.

---

# 11장. DIP: 의존성 역전 원칙

- “의존성이 극대화된 시스템”이란, 소스 코드 의존성이 추상에 의존하며 **구체에는 의존하지 않는** 시스템이다.
- 하지만 소프트웨어 시스템이라면 많은 장치에 반드시 의존하므로, 이를 규칙으로 보는 것은 비현실적이다.
- 따라서 DIP를 논할 때 운영체제나 플랫폼과 같이 안정성이 보장된 환경에 대해서는 무시한다.
- 의존하지 않도록 피하고자 하는 것은 변동성이 큰 구체적인 요소(우리가 개발 중이라서 자주 변경될 수 밖에 없는 모듈들)이다.

## **안정된 추상화**

- 인터페이스에 변경이 생기면 구현체들도 수정해야 하지만, 구현체들에 변경이 생기더라도 인터페이스는 대부분 변경될 필요가 없다.
- 인터페이스는 구현체보다 변동성이 낮으며, 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추려고 노력한다.
- 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력하며, 이는 소프트웨어 설계의 기본이다.
- 즉, 안정된 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻.

DIP에서 전달하려는 내용은 아래와 같이 매우 구체적인 코딩 실천법으로 요약할 수 있다.

- 변동성이 큰 구체 클래스를 참조하지 말라
    - 대신 추상 인터페이스를 참조하라
    - 이는 언어가 정적 타입이든 동적 타입이든 관계없이 모두 적용된다.
    - 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제함
- 변동성이 큰 구체 클래스로부터 파생하지 말라
    - 이 규칙은 이전 규칙의 따름 정리이지만, 별도로 언급할 만한 가치가 있다.
    - 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
    - 따라서 상속은 아주 신중히 사용해야 한다.
    - 동적 타입 언어라면 문제가 덜 되지만, 의존성을 가짐에는 변함이 없으므로 신중을 거듭해야 한다.
- 구체 함수를 오버라이드하지 말라.
    - 대체로 구체 함수는 소스 코드 의존성을 필요로 한다.
    - 따라서 구체 함수를 오버라이드 하면 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
    - 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

## **팩토리**

- 위의 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.
- 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문인데, 자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.

![image](https://user-images.githubusercontent.com/61778930/219890002-378ac018-9e44-4bd7-8103-30068bd67128.png)


어떤 의미인가?  

- 곡선은 아키텍처의 경계에 해당하는데, 구체적인 것들로부터 추상적인 것들을 분리한다.
    - 위는 추상 컴포넌트, 아래는 구체 컴포넌트에 해당한다.
    - 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.
    - 구체 컴포넌트는 비즈니스 로직을 위해 필요한 모든 세부 사항을 포함한다.
- 소스 코드 의존성과 제어 흐름이 다르다.
    - 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.
    - 제어 흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로 지른다.
    - 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전되므로, 이 원칙을 ‘의존성 역전’이라고 부른다.

### **구체 컴포넌트**

- 위의 그림에서 구체 컴포넌트에는 구체적인 의존성이 (ServiceFactoryImpl에서 ConcoreteImpl에 의존함) 있고, DIP에 위배된다. 하지만 이는 일반적이며 DIP 위배를 모두 없앨 수는 없다.
- 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모아 시스템의 나머지 부분과는 분리할 수 있다.

### **결론.**

- 고수준의 아키텍처 원칙을 다루면서 DIP는 몇번이고 계속 등장할 것임
- 그리고 DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 됨
- 의존성은 더 추상적인 엔티티가 있는 쪽으로만 향하는데, 이 규칙은 추후 의존성 규칙(Dependency Rule)이라고 부름
