- [05. 객체 지향 프로그래밍](#05-객체-지향-프로그래밍)
  - [결론](#결론)
- [06. 함수형 프로그래밍](#06-함수형-프로그래밍)
  - [결론](#결론-1)
- [07~11](#0711)
  - [SOLID](#solid)
    - [SOLID 원칙의 목적](#solid-원칙의-목적)
    - [SRP: 단일 책임 원칙(Single Responsibility Principle)](#srp-단일-책임-원칙single-responsibility-principle)
    - [OCP: 개방-폐쇄 원칙(Open-Closed Principle)](#ocp-개방-폐쇄-원칙open-closed-principle)
    - [LSP: 리스코프 치환 원칙(Liskov Substitution Principle)](#lsp-리스코프-치환-원칙liskov-substitution-principle)
    - [ISP: 인터페이스 분리 원칙(Interface Segregation Principle)](#isp-인터페이스-분리-원칙interface-segregation-principle)
    - [DIP: 의존성 역전의 원칙(Dependency Inversion Principle)](#dip-의존성-역전의-원칙dependency-inversion-principle)

# 05. 객체 지향 프로그래밍

OO는 최소한 다음 세가지 개념을 제공해야한다.

- `캡슐화(encapsulatio)`
- `상속(inheritance)`
- `다형성(polymorphism)`
  - 다형성은 OO에서 구현체를 쉽게 교체할 수 있게 해주는 개념이다
  - 여기에 의존성 역전을 사용하면 의존성 방향을 절대적으로 제어할 수 있게되고 모듈을 캡슐화해서 보호할 수 있다
  - `의존성 역전`
    - 보통 고수준 모듈에서 저수준 모듈을 의존하는 식으로 제어 흐름을 따르게 되는데
    - 의존성 역전은 여기서 interface를 활용해 의존성의 방향을 제어하는 방법이다.
    - 의존성 역전을 잘 활용하면 각 컴포넌트의 독립성을 가져갈 수 있고 개발 시에도 독립성을 가져갈 수 있다

## 결론

- OO란 무엇인가?
  - 아키텍트 관점에서 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 흭득할 수 있는 능력
  - OO를 사용하면 플러그인 아키텍처를 구성할 수 있고
  - 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
  - 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과 독립적으로 개발하고 배포할 수 있다.

# 06. 함수형 프로그래밍

함수형 프로그래밍에서 제일 중요한 것은 `불변성`이다

- 우리가 동시성 프로그래밍을 할 때 만나볼 수 있는 `경합(race) 조건`, `교착상태(deadlock) 조건`, `동시 업데이트(concurrent update) 문제`가 모두 가변 변수로 인해 발생하기 때문에 이런 것들을 불변성을 통해 제거하자는 맥락이다.
- `가변성의 분리`
  - 위에서 살펴본 내용에 따라 당연하게도 함수형 프로그래밍에서 불변성과 관련하여 가장 주요한 타협 중 **하나는 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.**
  - 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮기고 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

## 결론

지금까지 알아본 3가지 패러다임이 우리에게서 어떤 것들을 제한하는지 알아보자

- `구조적 프로그래밍`은 제어흐름의 직접적인 전환에 부과되는 규율이다
- `객체 지향 프로그래밍`은 제어흐름의 간접적인 전환에 부과되는 규율이다
- `함수형 프로그래밍`은 변수 할당에 부과되는 규율이다

# 07~11

좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로 부터 시작된다.

그렇다면 이런 깔끔한 코드, 좋은 소프트웨어 아키텍처를 정의하는 원칙은 무엇일까?

**바로 SOLID에 대해서 알아보자**

## SOLID

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.

- 클래스라는 단어를 사용했다고 해서 객체지향에만 적용되는 것은 아니다.
여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 의미!

### SOLID 원칙의 목적

**SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
*여기서 중간 수준의 소프트웨어는 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 사용할 수 있다는 뜻이다.**

- `변경에 유연하다`
- `이해하기 쉽다`
- `재사용성` : 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

### SRP: 단일 책임 원칙(Single Responsibility Principle)

- **각 소프트웨어 모듈은 변경의 이유가 단 하나이어야만 한다.**
- `콘웨이 법칙에 따른 따름정리`: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다.
- actor에 따라 역할을 분리해라
  - 같은 employee 데이터에 대해서 여러 케이스에 각각 다른 정산 계산식을 사용할 수 있는데
  - 이런 정산 계산식을 하나의 method에서 제공하면 해당 method에 변경사항이 생겼을 때 사이드 이펙트가 발생할 수 있다.
  - 그러므로 actor. 즉 해당 메서드를 사용하는 주체에 따라 class와 같은 모듈을 분리해라

### OCP: 개방-폐쇄 원칙(Open-Closed Principle)

- **기존 코드의 수정은 막아 보호하고 코드 추가로 인한 확장은 열려있게**
- **기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 행위를 변경할 수 있도록 설계해야만 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지**

### LSP: 리스코프 치환 원칙(Liskov Substitution Principle)

- **상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야만 한다.**
- 컴포넌트는 **interface같은 개념같이 쉽게 교체가 가능해야 한다.**

### ISP: 인터페이스 분리 원칙(Interface Segregation Principle)

- **이 원칙에 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.**

### DIP: 의존성 역전의 원칙(Dependency Inversion Principle)

- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다.
- 대신에 세부사항이 정책에 의존하도록 해야한다.
