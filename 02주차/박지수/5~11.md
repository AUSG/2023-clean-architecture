## 5장) 객체 지향 프로그래밍

### 객체 지향 설계 원칙 (Object-Oriented)

아래 세가지 개념을 조합한 것 혹은, 최소 아래 세 가지는 지원해야한다.

- `캡슐화(Encapsulation)`
- `상속(Inheritance)`
- `다형성(Polymorphism)`

### 캡슐화

- 응집력 있게 구성되어 있는 데이터와 함수를 구분 지어 접근 할 수 있게 한다.
- C언어에서 헤더와 구현체를 분리하는 방식으로 캡슐화를 완벽히 지원 하였지만, Java, C#은 헤더와 구현체 분리하는 방식을 버렸고, 이로 인해 캡슐화는 훼손되었다.
- 점점 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회 하지 않을 것이라는 믿음을 기반으로 하고 있다.

### 상속

- OO가 있기 전에도 C프로그래머는 언어의 도움 없이 구현할 수 있었다.
    - 맴버 변수의 순서를 갖게 하여 사용
    - CPP는 아직도 이 방법을 사용
    - 다중 상속을 구현하는 것은 매우 어려움
- OO 언어가 상속이라는 새로운 개념을 만들어 낸 것은 아니지만, 상당히 편리하게 사용 가능하게 만들어 주었다.

### 다형성

- OO가 있기 이전에도 포인터를 사용해 다형성을 구현할 수 있었다.
    - 함수 포인터의 위험함, 초기화 등 관례를 수동으로 꼭 해줘야함
- 다른 개념과 마찬가지로, OO 언어는 좀 더 안전하고 편리하게 다형성을 사용할 수 있게 해준 것이다.
    - ex) 플러그인 아키텍처를 쉽게 적용할 수 있게 되었다.

### 의존성 역전

- 기존에는 고수준에서 저수준으로 함수 호출하는 방향으로 개발되었다. (의존성의 방향 == 제어의 흐름)
- 다형성을 사용해 소스 코드의 의존성과 제어의 흐름을 반대로 만들 수 있다.
    - 소스 코드는 인터페이스를 의존하고 있다. (의존성의 방향)
    - 인터페이스는 런타임에는 존재하지 않고 구현체의 함수를 호출한다. (제어의 흐름)
- 작은 기능, 컴포넌트 단위로 컴파일/배포 할 수 있게 되었다. 
**→ 고수준의 정책을 포함하는 모듈과 세부 구현을 담당하는 저수준의 모듈을 독립 시킬 수 있게 되었다.**

## 6장) 함수형 프로그래밍

**함수형 언어에서는 가변 변수가 없다.**

### 불변성과 아키텍처

- 불변성이 왜 중요한가? → Race Condition, Deadlock, Concurrent update 문제 모두 가변성으로 인해 발생
- 불변하다면, 3가지 문제는 발생하지 않는다.
- 불변성은 많은 자원(저장 공간/프로세서의 속도)을 필요로 한다. 따라서 현실에서는 타협이 필요하다.
- 모두 불변으로 만들 수 없다면, 불변 컴포넌트와 가변 컴포넌트를 먼저 분리해야한다.

### 이벤트 소싱

- 데이터를 불변하게 만들고, Append Only 시스템에서 사용
- 변경 가능한 상태를 저장하는 것이 아니라, 변화/트랜잭션을 모두 저장하는 전략

## 2부 결론

- 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 부과되는 규율
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
- 함수형 프로그래밍은 변수 할당에 부과되는 규율

# 3부 — 설계 원칙

좋은 벽돌(Clean Code)을 사용하더라도 빌딩의 아키텍처를 망칠 수 있다.

좋은 아키텍처를 정의하는 원칙이 필요 → SOLID 원칙

SOLID의 3가지 목적

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 된다.

## 7장) SRP (단일 책임 원칙)

- 모듈은 오직 하나의 액터에 대해서만 책임져야 한다. → 모듈/클래스/코드가 변경되는 이유는 하나여야한다.
- 여러 액터가 의존하고 있는 모듈이 결합되면 안된다. → 나의 변경이 동료의 문제를 만들 수 있음

- 여러 액터의 기능을 서로 다른 클래스로 분리, 기본 데이터 구조만 공유
    - 여러 클래스 인스턴스가 만들어지고, 추적해야하는 단점을 갖고 있음
    - 하지만 서로 다른 책임을 가졌다고 할 수 있고, 퍼사드 패턴을 사용해 어느정도 단점 해결 가능

## 8장) OCP (개방 - 폐쇄 원칙)

- 소프트웨어 개체는 확장에는 열여 있어야 하고, 변경에는 닫혀 있어야 한다.
    - 기능이 추가 될 때, 기존 코드를 수정하는 것이 아니라 새로운 코드를 추가하는 방식으로 소프트웨어를 수정할 수 있어야 한다.
    - 변경으로부터 보호하려는 컴포넌트를 향하여 단방향으로 의존성을 그리면 된다.
- **고수준의 정책(추상화 레벨이 높다.)을 저수준의 정책(추상화 레벨이 낮다. == 변경이 잦다.) 변경/확장 으로부터 보호 할 수 있다.**
    - 예시에서는 정책을 담고 있는 Interactor(고수준)가 Database(저수준)의 변경/확장으로부터 보호 받고 있다.
    
    ![](https://i.imgur.com/AJgtM2m.png))
    
    - 우선순위는 낮지만 고수준의 변경으로부터 저수준도 보호 되길 바란다. 이를 위해 내부 은닉을 사용할 수 있다.
        - 책에서 Reuqset에서 한번 어댑팅(?)이 없었다면, Controller가 Intercator의 Entities에 추이 종송석을 가지게 된다. (내부 은닉으로 해결)

### 9장) LSP (리스코프 치환 원칙)

- **하위 타입이 되기 위해서는 치환하더라도 모든 행위가 변하지 않아야 한다.**
- Ex) 클라이언트(Billing)는 License(Interface)에만 의존하고 License의 두 하위 타입에 신경쓰지 않아도 된다.
- 정사각형은 직사각형의 하위 타입이 아니다.
    - 두개의 제약이 다르기 때문, 사용하기 위해서는 정사각형인지 아닌지 판단해야 한다. 
    → 즉, 어떤 구현체인지 알아야 한다.
- 초창기에 상속 사용 가이드하는 방법 정도로 간주. 시간이 지나면서 인터페이스/구현체에 적용되는 광범위한 소프트웨어 원칙이 되었다.
- LSP는 아키텍처 수준까지 확장해야 하며, 위배하였을 때 상당의 별도 매커니즘을 추가해야할 것이다.

## 10장) ISP (인터페이스 분리 원칙)

- 사용하지 않는 것에 의존하지 않아야 한다.
    - 의존 하는 컴포넌트, 클래스도 최소 단위로  나눠야 한다.
    → 의존하고, 책임을 위임하는 것 조차 책임이다. (SRP로 생각 할 수 있을 것 같다.)
    - 하나의 클래스에 다양한 기능이 모여 있고, 서로 다른 클래스에서 메서드를 하나씩 사용할 때, 메소드 하나의 변경은 모든 클래스의 컴파일/배포를 요구한다. → 각각의 기능을 인터페이스로 분리, 사용하는 기능의 인터페이스만 의존하여 해결
- 동적 언어가 결합도가 낮은 시스템을 만들 수 있다. 
(????잘 모르겠음, 보이지 않는 의존성이다. 명시적 의존을 걷어낸다고 의존성이 사라지는 것인가?)
    - 정적 타입 언어에 경우 선언문이 강제되기 때문에, 재컴파일 또는 재배포가 강제되는 상황이다.
    - 동적 타입 언어는 런타임 추론을 통해 재컴파일, 재배포가 강제되지 않는다.

## 11장) DIP (의존성 역전 원칙)

- 고수준 정책(추상화 레벨이 높음)은 저수준 세부사항(추상화 레벨이 낮음)을 의존하면 안된다.
    - 결국 추상화 레벨이 높고, 안정적이고, 변화가 적은 방향으로 의존해야한다는 의미
- 변동성이 큰 객체를 의존하고 있으면, 의존하고 있는 클래스/객체도 자주 변동되게 된다. 
→ 같이 변경 되기 때문에 같이 테스트, 빌드, 배포가 필요하다.
- 인터페이스를 사용하는 이유는 인터페이스가 구현체보다 변동성이 적기 때문이다.
    - 반대로 말하면 인터페이스가 변경 된다면, 모든 구현체를 바꿔줘야 할 수 있다. (뼈를 깎는 고통이다…)
- 시스템을 추상 컴포넌트와 구체 컴포넌트로 분리해서 생각해야한다.
- 구체 컴포넌트 간에는 구체적인 의존성이 존재한다.
    - 모두 DIP를 만족 시킬 수 없다. → DIP를 위배하는 구체 컴포넌트를 모아 분리하는 방법을 사용할 수 있다.
