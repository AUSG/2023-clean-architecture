# 5장 객체 지향 프로그래밍

## 캡슐화

>   많은 OO 언어에서는 캡슐화를 강제하지 않는다.

-   c언어에서는 헤더와 구현체를 분리하는 방식으로 캡슐화를 지원했다.
-   cpp에서는 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언해야했고, 이로 인해 캡슐화를 지키지 못했다.
-   Java, C#은 헤더와 구현체를 분리하는 방식을 아예 버렸고, 이로 인해 선언과 정의를 구별하는 것이 어려워졌다.



## 상속

>   상속만큼은 OO가 확실히 제공한다. 하지만, 상속이란 단순히 어떠한 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일일 뿐이다.

-   OO가 있기 전에도, C 프로그래머는 언어의 도움없이 구현 가능했다.
    -   멤버 변수의 순서를 그대로 유지하는 방법으로 사용하였다.
    -   하지만, 상속만큼 편리한 방법은 아니였다.
-   OO에서는 암묵적인 업캐스팅을 통해서, 상속을 구현하였다.



## 다형성

>   OO는 제어 흐름을 간접적으로 전환하는 규칙을 부과한다고 결론 지을 수 있다.

-   C언어에서는 함수를 가리키는 포인터를 응용한 다형성을 사용한다.
    -   함수포인터는 위험하고 초기화하는 관례를 지켜야한다.
    -   하지만, 이러한 관례는 망각되기 싶고 이는 버그를 일으키고 찾아내기도 없애기도 힘들다.
-   OO 언어는 이러한 관례를 없애고, 실수할 위험을 제거하였다.



### 다형성이 가진 힘

-   플러그인 아키텍쳐는 입출력 장치 독립성을 지원하기 위해 만들어졌지만, C언어에서는 함수 포인터를 다루어야하는 위험 때문에 거의 사용하지 않았다.
-   OO의 등장은 이러한 위험을 제거했고, 플러그인 아키텍쳐를 어디서나 적용할 수 있게 되었다.



### 의존성 역전 

-   옛날에는 고수준의 함수에서 저수준의 함수를 호출하는 방향으로 개발을 진행했다. 즉, 제어의 흐름을 따르게 된다.
-   하지만 다형성이 여기에 끼어들게 된다면, 인터페이스와 구현체 사이의 의존성이 반대가된다. 즉, 의존성 역전이 일어난다.
-   호출을 하는 쪽이든, 받는 모듈이든 상관없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.
-   이를 통해 분리된 컴포넌트 또는 배포 가능 단위로 컴파일할 수 있게 될 것이며, 의존성 역시 소스 코드 사이의 의존성과 같아질 것이다.
    -   배포 독립성과, 개발 독립성을 이루어 낼 수 있다.



## 결론

-   OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
-   OO를 통해 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
    -   저수준의 세부사항은 중요도가 낮은 플러그인으로 만들 수 있으며, 배포도 독립적으로 가능해진다.



# 6장 함수형 프로그래밍

## 정수를 제곱하기

-   함수형 언어에는 가변 변수가 전혀 없기에, 변수는 변경되지 않는다.

```clojure
(println ;___ 출력한다
  (take 25;___ 처음부터 25까지
  	(map (fn [x] (* x x))) ;__ 제곱을
       (range)))) ;___ 정수의
```



## 불변성과 아키텍처

-   Race condition, deadlock, concurrent update 모두 가변 변수로 인해 발생한다.
-   다시말해, 동시성 어플리케이션에서 발생하는 모든 문제는 가변 변수가 없다면 발생하지 않는다.
-   불변성은 많은 데이터를 담을 공간을 필요로하기 때문에, 어느 정도 타협이 필요하다.



## 가변성의 분리

-   가장 중요한 타협은 불변 컴포넌트와 가변 컴포넌트를 분리하는 일이다.
    -   불변 컴포넌트는 어떤 가변변수도 사용되지 않으며, 변수의 상태를 변경할 수 있는 다른 컴포넌트와 서로 통신한다.



## 이벤트 소싱



## 결론

-   구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
-   객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
-   함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
-   소프트웨어는 순차, 분기, 반복, 참조로 구성된다. 그 이상 그 이하도 아니다.



# 3부 설계 원칙

-   아키텍쳐를 정의하는 원칙이 필요한데, 이 때 사용되는 원칙이 SOLID다.
-   SOLID 원칙은 중간 수준의 소프트웨어가 아래와 같게 만들기 위함이다.
    -   변경에 유연하다.
    -   이해하기 쉽다.
    -   많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 된다.



# 7장 SRP

>   콘웨이 법칙에 따른 따름정리. 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈의 변경의 이유는 단 하나여야한다.

-   모듈이 단 하나의 일을 해야하는 것이 아니다. 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야한다.

-   모듈의 가장 단순한 정의는 소스파일이다.
-   다르게 정의하면, 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.



## 징후1: 우발적 중복

-   급여 어플리케이션에서 Employee 클래스를 생각해보자.
    -   이 클래스는 calculatePay(), reportHours(), save() 를 가진다.
    -   이 클래스는 SRP를 위반한다. 각 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문.
    -   calculatePay()
        -   회계팀에서 기능을 정의
    -   reportHours()
        -   인사팀에서 기능을 정의
    -   save()
        -   데이터베이스 관리자가 정의
-   개발자가 위 세가지 메서드를 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다.
    -   예를 들어, calculatePay() 메서드와 reportHours() 메서드가 regularHour() 메서드를 공유한다고 생각해보자.
    -   이 때, 회계팀의 이유로 인해 regularHour() 가 변경되면 reportHours() 가 영향을 받게된다.

-   이는 세가지 액터가 의존하는 코드가 너무 가까이 있기 때문이다.



## 징후 2: 병합

-   서로 다른 개발자가, Employee 클래스를 체크아웃하고 변경한다고 생각해보자.
    -   이들의 변경사항은 결과적으로 서로 충돌하며 병합이 발생할 것이다.
    -   병합이 발생하는 모든 경우를 해결할 수 없기에, 병합은 항상 위험이 뒤따른다.
-   이 문제를 해결하는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.



## 해결책

-   모두가 메서드를 각기 다른 클래스로 이동 시키는 방식이다.
-   각 클래스를 세 개의 클래스로 분리하고, 간단한 데이터 구조만 공유하도록한다. 이를 통해 우연한 중복을 피할 수 있다.
-   이 해결책은 세 클래스를 인스턴스화하고 추적해야하는 단점이 있으며, 이를 빠져나오기 위해 퍼사드 패턴을 많이 사용한다.
-   어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다.
    -   이 방식에는 중요 메서드를 기존 클래스에 유지하되, 그 클래스를 덜 중요한 다머지 메서들에 대한 퍼사드로 사용할 수도 있다.
    -   어떤 사람은 위 해결책이 모든 클래스가 단 하나의 메서드를 가져야한다는 주장을하며 반대할 수 있다.
    -   하지만 여러 메서드는 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구가 있는지를 전혀 알 수 없다.



## 결론

-   단일 책임 원칙은 클래스 수준의 원칙이다.
-   하지만, 컴포넌트 수준에서는 "공통 폐쇄 원칙"이 되며 아키텍쳐 수준에서는 아키텍쳐 경계의 생성을 책임지는 "변경의 축"이된다.



# 8장 OCP

>   기존 코드를 수정하는 방식보다, 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야하만 소프트웨어 시스템을 변경할 수 있다는 것이 요지이다.

-   소프트웨어 객체의 행위는 확장할 수 있어야하지만, 그 때 변경을 하면 안된다는 것.



## 사고 실험

-   이해관계자가 동일한 정보를 다른 방식으로 보여달라했을 때, 원래 코드를 수정하는 양의 이상적인 양은 얼마일까? 0이다.

    -   어떻게 하면 될까? 서로다른 목적으로 변경되는 요소를 적절히 분리하고, 요소 사이의 의존성을 체계화함으로써 변경량을 최소화 할 수 있다.

    -   처리과정을 클래스 단위로 분할하고, 이 클래스를 컴포넌트 단위로 분리하는 방식



![](https://i.stack.imgur.com/s20Hm.png)



-   FinancialDataMapper는 구현관계를 통해, FinancialDataGateway를 알고 있지만, FinancialDataGateway는 FinancialDataMapper에 대해 아무것도 알지 못한다.
-   화살표는 단방향이며, 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.



![](https://i.stack.imgur.com/z3MNd.png)

-   컴포넌트 관계는 모두 단방향으로 이루어져 있다. ( A 컴포넌트의 변경으로부터 B를 보호하려면, A가 B를 의존해야한다. )
-   예제의 경우
    -   Presenter에서 발생한 변경으로 부터 Controller을 보호하고자한다.
    -   View에서 발생한 변경으로 부터 Presenter을 보호하고자한다
    -   Interactor는 어느것에서 발생한 변경으로부터 보호된다.
        -   Interactor가 업무 규칙 ( 고수준의 정책 ) 을 포함하기 때문이다.
    -   Interactor > Controller, Databse > Prensenter > View

-   아키텍트는 기능이 왜, 어떻게, 언제 발생하는지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화 한다.
    -   이를 통해, 저수준의 컴포넌트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호할 수 있다.



## 방향성 제어

-   위 예시에서 FinancialDataGateway 인터페이스는 FinancialReportGenerator 와 FinancialDataMapper 사이에 존재하는데, 이는 의존성을 역전시키기 위해서이다.
-   위 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트와 Database 컴포넌트로 바로 향하게 된다.



## 정보 은닉

-   FinancialReportRequeser 인터페이스는 방향성 제어와는 다른 정보 은닉을 위해 존재한다.
    -   이 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.
    -   만약 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성을 가지게된다.
        -   추이 종속성 : A -> B, B -> C 와 같은 의존성을 가지면 A는 C를 의존하게되며 이를 추이 종속성이라한다.
    -   추이 종속성을 가지게 되면, 소프트웨어 엔티티는 자신이 직접 사용하지 않는 요소에 절대로 의존하면 안된다는 원칙을 위반하게 된다.

-   다시 말해, Controller에서 발생한 변경으로 부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호되기를 바란다.
    -   이를 위해, Interactor 내부를 은닉한다.



## 결론

-   OCP는 시스템의 아키텍쳐를 떠받치는 원동력 중 하나이다.
-   시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.
-   이 목표를 달성하기 위해서는 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어져야한다.



# 9장 LSP

>   상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야한다.



## 상속을 사용하도록 가이드하기

-   License에 PersonalLicense, BusinessLicense 라는 두가지 하위 타입이 존재한다.

-   이러한 방식으로 상속을 사용하면, License를 사용하는 Billing 클래스는 어떠한 구체 License 클래스를 사용하는지 알 수 없고 치환할 수 있다. 즉, LSP를 준수한다.ㅇ



## 정사각형 / 직사각형 문제

-   일반적인 상식으로 정사각형은 직사각형의 하위 집합이다.
-   하지만 상속을 사용했을 때, 정사각형이 직사각형을 상속하는 것은 적합하지 않다.
    -   직사각형은 높이와 너비가 독립적으로 변경될 수 있지만, 정사각형은 그렇지 않기 때문이다.
-   이러한 LSP 위반을 막기 위한 방법은 직사각형이 실제로는 정사각형인지 검사하는 메커니즘을 추가하는 것이다.
    -   하지만, 행위가 사용하는 타입에 의존하기 때문에 타입을 치환할 수 없게된다.



## LSP와 아키텍쳐

-   초창기에는 상속을 사용하도록 가이드 되었다. 하지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 설계 원칙으로 변모하였다.
-   이는 언어만이 아닌 여러 경우에도 사용할 수 있으며, 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문이다.



## LSP 위배 사례

-   REST API를 만들었다고 가정했을 때, 어떠한 업체의 대응을 위해 구현 내부에 if문을 추가했다고 가정해보자.
    -   이 업체가 더 커져서 다른 업체가 인수하여 이름이 변경되었을 때, if문을 더 추가하거나 수정해야하나? -> 이는 곧 문제를 일으킨다.
-   아키텍트는 이러한 것으로부터 시스템을 격리해야한다. ( 데이터베이스등을 사용하는 방법으로.. )



## 결론

-   LSP는 아키텍쳐 수준까지 확장할 수 있고, 확장해야하만 한다.
-   치환 가능성을 조금이라도 위배하면, 시스템 아키텍처가 오염되며 별도 메커니즘을 추가해야 할 수 있기 때문이다.



# 10장 ISP

>   소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

-   여러 클래스가 각각 특정한 클래스의 메서드를 단 하나씩만 사용하는 경우를 생각해보자.
    -   이 경우 특정 클래스의 메서드 하나만 변경되어도, 모든 클래스가 다시 컴파일되고 배포되어야한다.
    -   이것을 각각 인터페이스로 분리하면, 모든 클래스가 다시 컴파일 및 배포될 필요가 없어진다.



## ISP와 언어

>   ISP는 아키텍쳐가 아니라, 언어와 관련된 문제이다.

-   정적 타입 언어는 소스코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하고, 재컴파일 또는 재배포가 강제되는 상황이 발생한다.

-   동적 타입 언어는 런타임 추론을 통해 재컴파일과 재배포가 필요 없어진다.
    -   그렇기에 동적 타입 언어가 정적 타입 언어보다 유연하며 결합도가 낮은 시스템을 만들 수 있다.



## ISP와 아키텍쳐

-   필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
-   소스 코드 뿐 아니라 이러한 일은 아키텍쳐에도 발생한다.



## 결론

-   불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.



# 11장 DIP

>   고수준 정책의 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존하면 안된다. 대신 세부사항이 정책에 의존해야 한다.

-   유연성이 극대화되었다는 것은 소스 코드 의존성이 추상에 의존하며, 구체에는 의존하지 않는 것이다.
    -   정적 타입언어에서는 추상적인 선언만을 참조해야하며, 구체적인 대상에는 절대로 의존해서는 안된다.
-   하지만 위 정책은 현실성이 없고, 바로 변동성이 큰 구체적인 요소 즉 우리가 개발하는 자주 변경될 수밖에 없는 모듈에서라도 의존하지 않도록 피해야한다.



## 안정된 추상화

-   구체적인 구현체의 변경이 있더라도 대부분의 인터페이스에 영향이 없다.
    -   인터페이스는 구현체보다 변동성이 낮다
    -   인터페이스를 변경하지 않고 구현체를 변경하는 방식이 소프트웨어 설계의 기본이다.
-   즉, 안정된 소프트웨어 아키텍쳐란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍쳐라는 뜻이다.



### 구체적인 코딩 실천법

-   변동성이 큰 구체 클래스를 참조하지 말라
-   변동성이 큰 구체 클래스로부터 파생하지 말라
-   구체 함수를 오버라이드 하지 말라
-   구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라



## 팩토리

-   이러한 규칙을 준수하기 위해서는, 구체적인 클래스를 생성할 때 주의해야한다.
-   아키텍쳐 경계는 시스템을 컴포넌트로 분리하며, 추상 컴포넌트와 구체 컴포넌트로 분리한다.
    -   추상 컴포넌트는 애플레이케이션의 모든 고수준 업무 규칙을 포함한다.
    -   구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
-   소스 코드 의존성은 제어 흐름과는 반대로 역전되며, 이를 의존성 역전이라 부른다.



## 구체 컴포넌트

-   구체 컴포넌트에는 구체적인 의존성이 존재하여, DIP를 위배한다.
    -   이는 일반적이며, DIP를 위배하는 클래스들을 적은 수의 구체 컴포넌트 내부로 모아 분리하는 방법을 사용할 수 있다.



## 결론

-   앞으로 DIP는 아키텍쳐 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.
-   의존성은 추상적인 엔티티가 있는 쪽을 향해야하며, 이 규칙은 추후 의존성 규칙이라 부를 것이다.

