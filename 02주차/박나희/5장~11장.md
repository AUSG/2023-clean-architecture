## 5장 객체지향 프로그래밍

- 좋은 아키텍처를 만드는 일 → 객체 지향 설계원칙을 이해하고 응용하는 데서 출발
- 캡슐화, 상속, 다형성 : 객체 지향 언어는 세 가지 요소를 반드시 지원해야한다고 말하는 일측이 있음

### 캡슐화

- 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 객체지향 언어가 제공하기 때문에 언급됨
- But. 이 개념은 단지 객체지향 언어에만 국한된 것이 아닌, C언어에서도 완벽한 캡슐화가 가능하다
    - C에선 헤더 파일에 선언된 구조와 함수를 사용하지만, 구현파일에 작성된 항목에 대해서는 어떠한 방법으로도 접근할 수 없음
- 객체지향 언어인 C++ → 컴파일러가 클래스의 인스턴스 크기를 알도록 하기 위해 클래스의 멤버 변수를 무조건 헤더 파일에 선언할 것을 요구 → 완벽한 캡슐화가 꺠짐
- public, private, protected 등의 키워드로 불완전한 캡슐화를 보완하긴 함
    - JAVA, C#은 헤더파일, 구현체 분리하는 방식을 버림 → 캡슐화는 점점 심하게 훼손
- 객체지향을 주창한 언어들이 오히려 캡슐화를 약화시켜옴

### 상속

- 상속만큼은 객체지향언어가 좀 더 확실히 제공함
    - But. 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과 → C에서도 상속을 흉내내는 기법이 사용됨
- 그래도 객체지향언어는 업캐스팅을 암묵적으로 수행해주는 둥 데이터 구조에 가면 씌우는 일을 상당히 편리한 방식으로 제공함

### 다형성

- 함수를 가리키는 포인터를 응용한 것이 다형성 → 객체지향 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해준다
    - 함수에 대한 포인터를 직접 사용해 다형적 행위를 만드는 방식은 위험함 → 객체 지향 언어는 일종의 수동적이고 위험한 관례를 없애줌
    - 객체지향언어는 제어 흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있음

### 다형성이 가진 힘

- C의 예제에서 복사프로그램의 소스 코드는 입출력 드라이버의 소스코드에 의존하지 않음 → 새로운 장비에서 복사 프로그램을 동작 시킬 때, 단지 입출력 드라이버가 FILE에 정의된 다섯가지 표준함수를 구현하면 복사 프로그램은 입출력 드라이버 얼마든지 사용 가능
    - 입출력 드라이버 → 복사 프로그램의 플러그인이 됨
- OO의 등장으로 어디서든 플러그인 아키텍처를 적용할 수 있게 됨

### 의존성 역전

- 전형적인 호출 트리에서, 소스코드 의존성의 방향은 반드시 고수준에서 저수준으로 제어흐름을 따르게 된다
- 그러나 다형성이 끼어들며, 소스코드에서는 인터페이스와 구현체 간의 제어흐름이 역전되는 의존성 역전이 일어난다.
    - 소스코드 사이에 인터페이스를 추가함으로써 그 제어흐름을 역전시킬 수 있고, OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 의존성을 어디서든 역전시킬 수 있다는 의미이다.
- 의존성 배치를 이용해 개별적이며 독립적으로 배포 가능한 컴포넌트를 구성할 수 있고, 배포 독립성을 가질 수 있다.
    - 시스템 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있는 개발 독립성을 가질 수 있게 된다.

### 결론

- 소프트웨어 아키텍트 관점에서 객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
    - 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있음
    - 저수준의 세부사항은 중요도가 낮은 플로그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발 배포 가능

## 6장 함수형 프로그래밍

- 프로그래밍 보다 개념이 먼저 등장, 이 패러다임의 핵심은 람다 계산법

### 정수를 제곱하기

- 자바 프로그램은 가변 변수를 사용하지만, 클로저 프로그램에서는 가변 변수가 전혀 없다.
- 함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처

- 동시성 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 생기지 않는다.
- 불변성은 실현 가능한가? → 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제하면 실현 가능하지만, 일종의 타협이 필요하다

### 가변성의 분리

<img width="555" alt="image" src="https://user-images.githubusercontent.com/81923229/219905400-4a16d141-0683-490c-8728-8cd293b5be36.png">

- 불변 컴포넌트 - 순수하게 함수형 방식으로만 작업이 처리되며 어떤 가변 변수도 사용되지 않음 ⇒ 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트(가변 컴포넌트)와 서로 통신
- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 뺴내야 함

### 이벤트 소싱

- 상태가 아닌 트랜잭션을 저장하자는 전력, 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리
- 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없고, 애플리케이션은 CRUD가 아니라 그저 CR만 수행

### 결론

- 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 부과되는 규율
- 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 부과되는 규율
- 함수형 프로그래밍 : 변수 할당에 부과되는 규율
- 각각의 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정
- 소프트웨어는 결국 순차, 분기, 반복, 참조로 구성

# 3부 설계원칙

- SOLID:  좋은 벽돌로 좋은 아키텍처를 정의하는 원칙
    - 중간 수준의 소프트웨어 구조가 1. 변경에 유연하고 2. 이해하기 쉽고 3. 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 되도록 만드는 것이 목적
    - 여기서 중간수준은 프로그래머가 이 원칙들을 모듈 수준에서 작업할 떄 적용할 수 있다는 것

## 7장 SRP: 단일 책임 원칙

- 콘웨이 법칙에 따른 따름 정리: 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다
- 하나의 모듈은 오직 하나의 액터(변경을 요청하는 한 명 이상의 사람들)에 대해서만 책임져야 한다.
    - 모듈의 가장 단순한 정의는 소스파일이다.
    - 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 응집성

### 원칙 위반 징후

1. 우발적 중복
    
    <img width="610" alt="image" src="https://user-images.githubusercontent.com/81923229/219905407-6f895f97-2237-4c63-a335-9c9a6332c2dc.png">
    
    - 위 그림을 보았을 때, 한 클래스의 각 메서드가 서로 다른 액터를 책임지는 경우
    - 개발자가 위 세 가지 메서드를 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다.
    - calculatePay() 메서드와 reportHours() 메서드가 regularHour() 메서드를 공유한다고 하였을 때, calculatePay의 이유로 regularHour메서드가 변경되면 reportHours메서드도 영향을 받는다
    - 서로 다른 액터가 의존하는 코드를 너무 가까이 배치
2. 병합
    - 서로 다른 두 팀에서 각각 Employee 클래스 체크아웃 후 변경사항 적용하기 시작
        - 결국 변경사항 충돌하고 병합이 발생
        - 병합은 항상 위험이 뒤따름
    - 서로 다른 액터를 뒷받침하는 코드를 서로 분리해야 함

### 해결책

- 데이터와 메서드를 분리하는 것이 가장 확실한 해결책
    - 각 클래스는 자신의 메서드에 반드시 필요한 소스코드만을 포함
    - 세 클래스는 서로의 존재를 몰라야 함 → 우연한 중복 피할 수 잇음
    - 그러나 세 가지 클래스를 인스턴스화하고 추적해야하므로, 이걸 빠져나오기 위해 퍼사드 패턴을 사용
- 어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하길 원함 → 중요한 메서드들은 Employee 클래스에 유지하되 Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 이용
    - 모든 클래스가 단 하나의 메서드를 가져야 한다는 주장에 근거해 어떤 사람은 위 해결책에 반대할수도
    - 하지만 여러 메서드는 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다. 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구가 있는지를 전혀 알 수 없다.

### 결론

- 단일 책임 원칙은 메서드와 클래스 수준의 원칙
- 컴포넌트 수준에서는 공통 폐쇄의 원칙
- 아키텍처 수준에서는 아키텍처의 경계 생성을 책임지는 변경의 축이 됨

## 8장 OCP: 개방-폐쇄 원칙

- 기존 코드를 수정하기 보다 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다

### 사고 실험

- 변경되는 코드의 양이 가능한 한 최소화 되도록
    - 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고 (SRP)
    - 이들 요소 사이의 의존성을 체계화 함으로써 (DIP)

<img width="659" alt="image" src="https://user-images.githubusercontent.com/81923229/219905412-43fe1444-459c-4caf-ac32-5ddd44e82dc3.png">

- 이중선 - 컴포넌트, 화살표 열려있으면 사용 관계, 닫혀있으면 구현 관계 혹은 상속 관계
- presenter에서 발생한 변경으로부터 controller를 보호, view에서 발생현 변경으로부터 presenter를 보호, Interactor는 다른 발생한 모든 변경으로부터 보호
- Interactor→ 애플리케이션의 가장 높은 수준의 정책을 포함하고, 이 이외의 컴포넌트는 모두 주변적인 문제를 처리함
- 보호의 계층 구조가 수준이라는 개념을 바탕으로 생성 → Interactor > Controller > Presenter > View
- 아키텍처 수준에서 OCP가 동작하는 방식 ) 아키텍트는 기능이 어떻게, 왜, 언제 발생하는 지에 따라 기능을 분리하고, 분리한 기능을 컴포넌트의 계층 구조로 조직화
    - 저수준 컴포넌트의 변경사항으로부터 고수준 컴포넌트를 보호

### 방향성 제어

- FinancialDataGateway인터페이스는 FinancialReportGenerator와 FinancialDataMapper사이에 위치 → 의존성을 역전시켜 의존성이 interactor컴포넌트에서 database컴포넌트로 바로 향하게 되는 것을 막음

### 정보 은닉

- FinancialReportRequester인터페이스는 방향성 제어와는 다른 목적을 가짐 → FinancialReportController가 Interactor내부에 대해 너무 많이 알지 못하도록 막기 위해 존재
    - FinancialReportRequester 인터페이스가 없으면 Controller는 FinancialEntities에 대해 추이종속성을 가지게 됨 → 그럼 소프트웨어 엔티티는 자신이 직접 사용하지 않는 요소에서는 절대 의존해서는 안된다는 소프트웨어 원칙을 위반하게 됨
- Interactor에서 발생한 변경으로부터 Controller도 보호되기를 원하기 때문에 Interactor내부를 은닉 (반대의 방향성이 우선순위가 가장 높지만)

### 결론

- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 바디 않도록 하는 데에 있음
- 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어지도록 해야 함

## 9장 LSP: 리스코프 치환 원칙

- 상호 대체 가능한 구성 요소를 이용해 소프트웨어 시스템을 만들 수 있으려면 이들 구성요소는 반드시 서로 치환 가능해야한다는 계약을 지켜야 한다.

### 상속을 사용하도록 가이드하기

<img width="652" alt="image" src="https://user-images.githubusercontent.com/81923229/219905419-5ce5f890-be96-474c-bf0a-acd170191c7f.png">

- LSP준수 → Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는 지에 전혀 의존하지 않음

### 정사각형/ 직사각형 문제

- Square는 Rectangle의 하위 타입이 되 수 없다 → Square의 높이와 너비는 반드시 함께 변경되기 때문

### LSP와 아키텍처

- LSP는 처음에 상속을 사용하도록 가이드 하는 방법 정도로 간주되었는데, 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모함

### LSP 위배 사례

- 택시 파견 서비스를 통합하는 애플리케이션 → 다양한 택시 업체에서 동일한 REST인터페이스를 반드시 준수하도록
- 만약 acme가 다른 택시업체를 인수하면 → 파견 uri를 key로 사용하는 데이터베이스를 이용하는 파견 생성 모듈을 만들어야 할 수도 있다 ) 버그로부터 시스템을 격리해야 함

### 결론

- 아키텍처 수준까지 확장할 수 있고, 확장해야만 함.
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야할 수 있기 때문

## 10장 ISP: 인터페이스 분리 원칙

- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다

### ISP와 언어

- 정적 타입 언어는 사용자가 타입선언문을 사용하도록 강제
- 동적타입언어에서는 선언문이 존재하지 않고 런타임에 추론이 발생 → 소스코드 의존성이 아예 없음
    - 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있음
- ISP를 언어 이슈로 결론지을 여지가 있음

### ISP와 아키텍처

- 필요 이상으로 많은 것을 포함하는 모듈에 의존하는 것은 해로운 일이다 → 소스 코드 의존성의 경우 이는 분명한 사실인데 불필요한 재컴파일과 재배포를 강제하기 때문
- 더 고수준인 아키텍처 수준에서도 마찬가지인 상황이 발생
    - S 시스템 구축에 참여하고 있는 F라는 프레임 워크에서 D라는 데이터 베이스를 사용한다면 ? → D내부가 변경되었을 때 다 재배포 해야할지도

### 결론

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠질 수 있음

## 11장 DIP: 의존성 역전 원칙

- 고수준의 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안되고, 세부사항이 정책에 의존해야 한다.

### 안정된 추상화

- 추상 인터페이스에 변경이 생기면 이를 구체화 한 구현체들도 따라서 수정해야 함.
    - 다만 구현체에 변경이 생겨도 인터페이스는 대다수의 경우 변동이 필요 없음 → 인터페이스는 구현체보다 변동성이 낮다.
- 안정된 소프트웨어 아키텍처랑 변동성이 큰 구현체에 의존하는 일을 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처
    1. 변동성이 큰 구체 클래스를 참조하지 마라
    2. 변동성이 큰 구체 클래스로부터 파생하지 말라
    3. 구체 함수를 오버라이딩 하지 말라
        1. 구체함수는 소스코드 의존성을 필요로 하므로 의존성을 상속받게 되어버림
    4. 구체적이며 변동성이 크다면 절대 그 이름을 언급하지 마라 

### 팩토리

- 객체 지향 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 코드 의존성이 발생 ⇒ 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 함

<img width="656" alt="image" src="https://user-images.githubusercontent.com/81923229/219905433-1a06fefa-4b61-4a92-aaa3-443ef4bfb5cb.png">

- Applcation은 Service인터페이스를 통해 ConcreteImpl을 사용하지만, Application에서는 어떤 식으로든 ConcreteImpl의 인스턴스를 생성해야 함
    - ConcreteImpl에 대한 의존성을 만들지 않기 위해 ServiceFactory의 makeSvc메서드를 호출 → makeSvc는 ServiceFactoryImpl에서 구현 → ConcreteImpl구현체가 ConcreteImpl인스턴스 생성 후 Service타입으로 반환
- 곡선을 기준으로 추상컴포넌트와 구체 컴포넌트가 나뉨
- 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한
- 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한
- 소스코드 의존성은 제어흐름과는 반대방향으로 역전된다.

### 구체 컴포넌트

- 구체컴포넌트에는 구체적인 의존성이 하나 있고 → DIP에 위배
    - ServiceFactoryImpl 구체클래스가 ConcreteImpl 구체 클래스에 의존
- DIP위배를 모두 없앨 수는 없음, 구체컴포넌트를 최소한 하나는 포함할 것인데, 이 컴포넌트를 main이라고 부름
    - main함수는 ServiceFactoryImpl의 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory타입으로 전역에 저장할 것, Application은 이 전역변수를 이용해 ServiceFactoryImpl인스턴스에 접근할 것

### 결론

- DIP아키텍처 다이어그렘에서 가장 눈에 드러나는 원칙이 될 것
- 추상/구체 컴포넌트를 분리하던 곡선은, 후에 아키텍처 경계가 될 것이며, 의존성은 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향한다 → ‘의존성 규칙’