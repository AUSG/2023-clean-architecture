# 20. 업무 규칙

>   업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차이다.

-   대출에 *N%* 이자를 부과한다는 사실은 은행이 돈을 버는 업무 규칙이다.
    -   컴퓨터 프로그램이든, 직원이 주판으로 계산하든 하등 관계 없다.
    -   이러한 규칙을 **핵심 업무 규칙**이라 한다.

-   핵심 업무 규칙은 보통 데이터를 요구한다.
    -   이러한 데이터를 **핵심 업무 데이터**라고한다.
    -   이러한 데이터는 자동화되지 않는 경우도 존재한다.



## 엔티티

> 엔티티는 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.

아래의 Loan 엔티티는 세 가지의 핵심 업무 데이터를 포함하며, 세 가지 핵심 업무 규칙을 인터페이스로 제공한다.

| Loan                                                         |
| :----------------------------------------------------------- |
| - principle<br />- rate<br />- period                        |
| + makePayment()<br />+ applyInterest()<br />+ chargeLateFee() |

- 이 클래스는 업무의 대표자로서 독립적으로 존재한다.
- DB, UI, Framework등에 의해 오염되면 안된다.



## 유스케이스

> 자동화된 시스템이 사용되는 방법을 설명한다. 사용자가 제공해야하는 입력, 사용자에게 보여줄 출력, 해당 출력을 생성하기 위한 처리 단계를 기술한다.

- 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다.
	- 유스케이스는 엔티티가 언제 춤을 출지를 제어한다.
	- 유스케이스는 사용자에게 어떻게 보이는지를 설명하지 않는다.

-   유스케이스는 단일 어플리케이션을 위한 것이기 때문에 저수준이며, 엔티티는 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로 고수준이다.
    -   유스케이스는 엔티티에 의존한다. 반면, 엔티티는 유스케이스에 의존하지 않는다.



## 요청 및 응답 모델

-   유스케이스는 데이터를 또 다른 컴포넌트와 주고 받는 방식에 대해서 전혀 눈치챌 수 없어야한다.
-   요청 및 응답 모델이 엔티티와 매우 유사하여 데이터 구조에 포함하려는 유혹을 가질 수도있지만, 시간이 지나면 매우 다른 노선으로 바뀌기 때문에 잘 분리하자.



## 결론

-   업무 규칙은 소프트웨어 시스템이 존재하는 이유다.
-   업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 코드를 포함한다.
    -    집안의 가보
-   UI, DB와 같은 저수준의 관심사에 의해 오염되면 안된다.
-   업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.



# 21. 소리치는 아키텍쳐

>   애플리케이션 아키텍처는 "어떠한 시스템이야"라고 소리쳐야한다. 자신이 "스프링/하이버네트야"라고 소리치면 안된다.



## 아키텍쳐의 테마

-   소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조
-   소프트웨어 애플리케이션의 아키텍처는 유스케이스에 대해 소리쳐야한다.
-   프레임워크가 중심이면 절대 안된다.



## 아키텍처의 목적

-   좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크와 도구 그리고 그 환경에 제약을 받지 않아야함.
-   좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있어야한다.



## 하지만 웹은?

-   웹은 입출력 장치일 뿐이며, 아키텍처가 아님
-   미루어야 할 결정사항 중 하나



## 프레임워크는 도구일 뿐, 삶의 방식이 아니다

>   프레임워크가 모든 것을 하게 하자는 우리가 취하고 싶은 태도가 아니다.

-   프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하자.



## 테스트하기 쉬운 아키텍처

-   프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위테스트를 할 수 있어야한다.
-   테스트를 돌릴 때, 웹서버 혹은 데이터베이스가 필요한 상황이 오면 안됨.
    -   유스케이스 객체가 엔티티 객체를 조작해야함.
    -   프레임워크로인한 어려움을 겪지 않고, 반드시 있는 그대로 테스트 할 수 있어야한다.



## 결론

-   아키텍처는 시스템을 이야기해야함. 프레임워크에대해 이야기하면 안됨.



# 22. 클린 아키텍처

>   관심사의 분리가 중요하다.

헥사고날, DCI, BCE 아키텍처는 모두 아래의 특징을 지니도록 만든다.
- 프레임워크 독립성
- 테스트 용이성
- UI 독립성
- 데이터베이스 독립성
- 모든 외부 에이전시와의 독립성

![CleanArchitecture](/Users/seongilkim/workspace/2023-clean-architecture/04주차/김성일/CleanArchitecture.jpg)

##  의존성 규칙

>   소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

-   내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
    -   내부의 원에 속한 요소는 외부의 요소의 어떤 것에 대해서도 언급하면 안된다.



### 엔티티

-   엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.
-   특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.



### 유스케이스

-   애플리케이션에 특화된 업무규칙을 포함한다.



### 인터페이스 어댑터

-   일련의 어댑터들로 구성된다.
-   어댑터는 엔티티와 유스케이스에 가장 편리한 형식에서 영속성용으로 사용중인 임의의 프레임워크가 이용하기에 가장 편리한 형식으로 변환한다.
-   데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.



### 프레임워크와 드라이버

-   모든 세부사항이 위치하는 곳이다.
-   우리는 이러한 것들을 모두 외부에 위치시켜서 피해를 최소화한다.



### 원은 네 개여야만 하나?

-   예시일뿐, 더 많아도 상관 X
-   하지만, 어떤 경우에도 의존성 규칙은 적용된다.



### 경계 횡단하기

-   제어흐름과 의존성의 방향이 명백히 반대인경우, 의존성 역전을 사용한다.
-   따라서, 유스케이스가 내부 원의 인터페이스를 호출하도록하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만든다.



### 경계를 횡단하는 데이터는 어떤 모습인가

-   간단한 데이터 구조로 이루어져있다.
-   경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태여야한다.



### 전형적인 시나리오

![scenario](/Users/seongilkim/workspace/2023-clean-architecture/04주차/김성일/scenario.png)

-   Controller에서 InputBoundary interface를 통해 Use Case Interactor에 전달한다.
-   Use Case Interactor는 Entities 가 어떻게 춤출지를 제어하고, Data Access Interface를 통해 Entity가 사용할 데이터를 메모리에 로드한다.
-   Entities가 완성되면, Use Case Interactor는 Entities로부터 데이터를 모아 OutputData를 구성하고  OutputBoundary 인터페이스를 통해 Presenter로 전달한다.
-   Presenter는 OutputData를 ViewModel과 같이 화면에 출력할 수 있는 형식으로 재구성하고, 이것을 View에서 출력한다.



## 결론

-   간단한 규칙들을 준수하는 일은 어렵지 않으며, 고통거리를 덜어줄 것이다.
-   계층을 분리하고, 의존성 규칙을 준수한다면 테스트하기 쉬운 프로그램을 만들게 될 것이며, 그에 따른 이점을 얻을 수 있다.



# 23. 프레젠터와 험블 객체

## 험블 객체 패턴

-   테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안된 디자인 패턴.
-   행위들을 두 개의 모듈 또는 클래스로 나눈다. 이 중 하나가 험블이고, 가장 기본적인 본질은 남기고 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.



## 프레젠터와 뷰

-   뷰는 험블 객체이고 테스트하기 어렵다
    -   뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지 않는다.
-   프레젠터는 테스트하기 쉬운 객체다. 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만든다.
-   뷰는 뷰 모델의 데이터를 화면으로 로드할뿐, 뷰가 맡은 역할은 없다. 뷰는 보잘 것 없다.



## 테스트와 아키텍처

-   테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져왔다.
-   테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의된다.



## 데이터베이스 게이트웨이

-   데이터베이스 게이트웨이 인터페이스를 유스케이스가 호출
-   구현체는 데이터베이스 계층에 위치하고, 험블 객체임.
-   하지만 인터페이스를 통해, 테스트 더블 혹은 스텁을 구현할 수 있음. 따라서, 유스케이스는 테스트하기 쉬움.



## 데이터 매퍼

-   데이터는 모두 private으로 선언되므로, 객체의 사용자는 데이터를 볼 수 없음.
    -   public 메서드만 볼 수 있고, 사용자 입장에서 객체는 오퍼레이션의 집합.
-   그렇기에, ORM은 단순히 데이터 매퍼임. 데이터베스 게이트웨이와 데이터베이스 사이에 존재하는 험블객체이다.



## 서비스 리스너

-   서비스 리스너에서도 험블 객체 패턴을 발견할 수 있음.



## 결론

-   아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템 테스트 용이성을 크게 높일 수 있다.



# 24. 부분적 경계

>   선행적인 설계가 YAGNI 원칙을 위배하기 때문에 애자일쪽에서는 탐탁치않게 여긴다. 하지만, 아키텍트라면 그것이 어쩌면 필요할 수 있다는 생각을 할 수 있고 그것을 부분적 경계를 통해 구현해볼 수 있다.



## 마지막 단계를 건너뛰기

-   독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아두기.



## 일차원 경계

-   완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를  사용한다.
    -   격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이든다.
-   전략 패턴을 사용하여 의존성 역전을 지킬 수 있음.
    -   하지만, ServiceImpl이 직접 Client를 의존하는 것을 막을 방법은 없음.



## 퍼사드

-   퍼사드 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다.
    -   클라이언트는 이들 클래스에 직접 접근 할 수 없다.

-   하지만 추이 종속성을 가져, 서비스 클래스 중 하나에서 소스 코드가 변경되면, client도 무조건 재컴파일해야할 것이다.



## 결론

-   위 세가지 접근법은 각각 장단점을 가진다.
-   아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽히 혹은 부분적을 구현할지를 정하는 것도 아키텍트의 역할이다.



# 25. 계층과 경계

-   이 장에서는 옴퍼스 사냥게임이라는 간단한 게임을 기반으로, 그것을 점점 확장해나간다.

-   의존성의 방향과, 각 경계의 흐름을 분리하고, 어떠한 추가사항이 발생했을 대 그것을 더 많은 흐름으로 분리하여 경계를 생성하는 방식에 대해서 설명한다.



## 결론

-   아키텍처 경계는 어디에나 존재한다.
-   아키텍처 경계가 언제 필요로한지, 신중하게 파악해야하며 오버 혹은 언더 엔지니어링이 되지 않도록 주의 깊게 살펴봐야한다.
-   조짐을 잘 살피고, 경계를 구현하는 비용과 무시할 때 비용을 가늠하여 변곡점에서 경계를 구현해야한다.
