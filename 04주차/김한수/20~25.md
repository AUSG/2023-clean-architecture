# 20~25

- [20~25](#2025)
- [20. 업무 규칙](#20-업무-규칙)
  - [엔티티](#엔티티)
  - [유스케이스](#유스케이스)
  - [요청 및 응답 모델](#요청-및-응답-모델)
  - [결론](#결론)
- [21. 소리치는 아키텍처](#21-소리치는-아키텍처)
  - [결론](#결론-1)
- [22. 클린 아키텍처](#22-클린-아키텍처)
  - [의존성 규칙](#의존성-규칙)
  - [엔티티](#엔티티-1)
  - [유스케이스](#유스케이스-1)
  - [인터페이스 어댑터](#인터페이스-어댑터)
  - [계층은 꼭 4개여야 하는가?](#계층은-꼭-4개여야-하는가)
  - [결론](#결론-2)
- [23. 프레젠터와 험블 객체](#23-프레젠터와-험블-객체)
  - [험블 객체 패턴](#험블-객체-패턴)
  - [결론](#결론-3)
- [24. 부분적 경계](#24-부분적-경계)
  - [부분적 경계를 만드는 방법](#부분적-경계를-만드는-방법)
  - [결론](#결론-4)
- [25. 계층과 경계](#25-계층과-경계)
  - [결론](#결론-5)

# 20. 업무 규칙

애플리케이션을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.

- `업무 규칙`
  - 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차이다.
  - 즉 도메인과 밀접한 `비즈니스 로직`을 뜻한다.
- 핵심 업무 규칙은 보통 규칙을 맞춰보기 위해 데이터를 요구하게되고 따라서 핵심 규칙과 핵심 데이터는 본질적으로 결합되게 된다.
- 그리고 이 결합된 규칙과 데이터는 곧 객체로 만들 좋은 후보가 된다.
이렇게 만들어진 객체를 우리는 `엔티티(Entity)`라고 칭한다.

## 엔티티

`엔티티`**는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.**

- **엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.**
- **이렇게 만들어진 엔티티는 핵심적인 도메인 비즈니스 로직을 응집하고 독립적으로 존재한다.**
- **그리고 이 클래스는 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 안된다. → 순수하게 유지해라**

e.g.

```java
class Loan {
 principle
 rate
 period 

 ... makePayment() { ... }
 ... applyInterest() { ... }
 ... chargeLateFee() { ... }
 
}
```

## 유스케이스

모든 업무 규칙이 엔티티처럼 순수한 것은 아니다.
자동화된 시스템이 동작하는 방법을 정의하고 제약하는 업무 규칙도 존재하게 되는데 우리는 이를 `유스케이스` 라고 부른다.

- 유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다.
  - 사용자가 제공해야 하는 입력,
  - 사용자에게 보여줄 출력,
  - 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.
- 즉. 엔티티 내의 핵심 업무 규칙과는 반대로 `애플리케이션에 특화된 업무 규칙`을 설명한다
  - e.g. 대출 실행 시 신용점수가 xxx점 이상이여야한다. 등

```java
class LoanUseCase {

 // 대출 신청
 ... applicationLoan() { 
  // 신용점수가 500점 이상인지 검사
  // 대출 엔티티 생성
  // etc...
 }
 
}
```

## 요청 및 응답 모델

요청 및 응답 모델은 자주 변경될 수 있으므로 독립적이여야한다.

- 따라서 어떤 이유로든 엔티티 객체를 가치키는 참조를 요청 및 응답 모델에 포함해서는 안된다.
  - 이는 공통 폐쇄 원칙과 단일 책임 원칙을 위배하는 행위이다
  - 이를 어기면 결국 허용하지 않은 떠돌이 데이터가 만들어지고 수많은 조건문이 추가될 것이다.

## 결론

**업무 규칙을 표현하는 코드는 반드시 시스템의 중심부에 위치해야하며
시스템에서 가장 독립적이고 가장 많이 재사용할 수 있는 코드가 되도록 유지해야한다.**

- 최대한 보호하고 UI, DB와 같은 저수준 관심사로 인해 오염되어서는 안된다.

# 21. 소리치는 아키텍처

아키텍처는 이 아키텍처가 어떤 시스템을 뜻하는지 보여준다.
내가 개발하고 있는 애플리케이션의 아키텍처가 ‘카드 추천 시스템이야’라고 소리치는지, ‘스프링/하이버네이트야’라고 소리치는지 점검해보자.

- 아키텍처는 프레임워크에 대한 것이 아니고 절대 그래서도 안된다.
- 좋은 아키텍처는
  - 유스케이스를 중심에 두어야하고
  - 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 가져야하며,
  - 프레임워크, 데이터베이스, 웹 서버 그리고 개발 환경 등에 대해서 최대한 결정을 미룰 수 있도록 도와준다.
  - 따라서 프레임워크는 사용하는 도구일뿐 아키텍처가 준수해야 할 대상이 아니며 프레임워크로부터 아키텍처를 제공받아서는 안된다.

## 결론

아키텍처는 시스템을 이야기해야하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.

- 당신이 헬스 케어 시스템을 구축하고 있다면 새로 들어온 프로그래머가 소스 저장소를 봤을 때 첫 인상은
‘오, 헬스 케어 시스템이군’이어야 한다.
- 그리고 해당 시스템이 어떻게 전달될지 알지 못한 상태에서도 모든 유스케이스에 대해 이해할 수 있어야하며
- 새로 들어온 프로그래머가
‘모델처럼 보이는 것들을 확인했습니다 뷰와 컨트롤러는 어디에 있죠?’ 라고 물었을 때
‘그것은 세부사항이니 당장은 고려할 필요가 없습니다. 나중에 결정할 것입니다.’ 라고 대답할 수 있어야한다.

# 22. 클린 아키텍처

수십 년간 시스템 아키텍처와 관련된 여러가지 아이디어(헥사고날 아키텍처 등)에 대한 내용을 살펴보면
모두 세부적인 면에서는 다소 차이가 있지만 공통적으로 `관심사의 분리`를 목표로 한다는 걸 알 수 있다.

- 이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 한다.
  - `프레임워크 독립성`
    - 프레임워크가 지닌 제약사항을 시스템에 욱여 넣도록 강제하지 않는다.
  - `테스트 용이성`
    - 업무 규칙(비즈니스 로직)은 UI, DB, 웹 서버, 혹은 외부 요소들 없이도 테스트할 수 있어야한다.
  - `UI 독립성`
    - 시스템의 나머지 부분을 수정하지 않고도 UI를 쉽게 변경할 수 있다.
  - `데이터베이스 독립성`
    - 업무 규칙은 DB에 결합되지 않으며 유연하게 DB 시스템을 교체할 수 있어야한다.
  - `모든 외부 에이전시에 대한 독립성`

위에서 나열한 특징을 하나의 아이디어로 통합해보면 아래와 같은 다이어그램이 나온다.

![1.png](https://user-images.githubusercontent.com/72328687/222934602-06efefa5-61bd-43e5-94a9-88084fb1bf84.png)

## 의존성 규칙

- 소스 코드 의존성은 반드시 저수준에서 고수준의 정책을 향해야한다.
- 그래야 저수준의 수정사항에 대해서 고수준의 정책을 훼손하지 않도록 방지할 수 있다.

## 엔티티

- 엔티티는 `전사적인 핵심 업무`를 캡슐화함
- 메서드를 가지는 객체 혹은 일련의 데이터 구조와 함수의 집합일 수도 있음. 즉, 형태는 중요하지 않음.

## 유스케이스

- 유스케이스는 `애플리케이션에 특화된 업무 규칙`을 포함함
- 이 계층에서 발생한 변경사항은 엔티티에 영향을 줘서는 안됨

## 인터페이스 어댑터

- 인터페이스 어댑터 계층은 일련의 어댑터들로 구성됨.
- 어댑터는 단순히 엔티티나 유스케이스, DB나 웹 같은 외부 에이전시에서 **쓰기 편리한 형태로
테이터를 변환하는 역할**을 한다.

## 계층은 꼭 4개여야 하는가?

- No.
- 그저 의존성 흐름, 계층 분리 등의 개념을 설명하기 위한 방안일뿐 4개일 필요는 없다.
- 더 많은 수의 계층이 필요할 수도 있고 적을 수도 있다.
- 하지만 어떤 경우에도 저수준에서 고수준의 정책으로 의존성이 흐르는 `의존성 규칙`은 적용되어야한다.

## 결론

- 위와 같은 간단한 규칙을 지키는 건 어렵지 않고, 향후에 겪을 수많은 고통거리를 줄여줄 것이다.
- 그리고 계층을 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이다.

# 23. 프레젠터와 험블 객체

`프레젠터`는 22장에서 다이어그램으로 살펴봤듯이 인터페이스 어댑처 계층에 속한다.

- `프레젠터`는 `험블 객체(Humble object)` 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.
- 실제로 22장에서 살펴본 클린아키텍처는 험블 객체 구현체들로 가득 차 있다.

## 험블 객체 패턴

`험블 객체 패턴` 은 단순히 테스트를 쉽게 하기 위해 테스트가 어려운 영역에 대해서는 험블 객체에 담고 테스트하고 싶은 코드들은 새로운 객체로 분리하는 것이다.

- 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.
  - 그리고 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.
- e.g. **GUI에서 수행하는 테스트는 작성하기 매우 어려운데, 사실 GUI에서 수행하는 행위는 쉽게 테스트할 수 있다. 그래서 이런 코드들을 따로 분리한다.**

## 결론

각 아키텍처 경계마다 험블 객체 패턴을 발견할 수 있을 것이다.

- 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반하는 경우가 많고
- 대개 그 경계는 테스트하기 어렵거나 쉬운 경우로 분리될 것이다.
- 이러한 아키텍처 경계에서 `험블 객체 패턴`을 사용하면 전체 시스템의 `테스트 용이성`을 크게 높일 수 있다.

# 24. 부분적 경계

아키텍처 경계를 완벽하게 만드는 것은 비용이 많이 든다.

- 그리고 이를 유지하는 데도 엄청난 노력이 필요하다.
- 뛰어난 아키텍트라면 이러한 경계를 만드는 비용이 너무 크다고 판단하면서도,
- 나중에 필요할 수도 있으므로 이러한 경계에 필요한 공간을 확보하기 원할 수도 있다.
- 이런 경우 `부분적 경계`를 구현해볼 수 있다.

## 부분적 경계를 만드는 방법

부분적 경계를 만드는 3가지 방법에 대해서 알아보자

- `컴포넌트를 분리할 준비는 하되 단일 컴포넌트를 유지한다.` (=마지막 단계 건너뛰기)
  - 독립적으로 컴파일하고 배포할 수 있는 작업은 모두 수행한 후.
  - 이 코드들을 옮기지 않고 단일 컴포넌트에 유지한다.
  - 이러면 다수의 컴포넌트를 관리하지 않으므로 배포 관리 부담이 없다.
- `일차원 경계`
  - Service interface를 두고 ServiceImpl를 구현하고 client가 이를 의존하도록 한다.
  - 이는 미래에 서비스를 다른 컴포넌트로 분리할 때의 기반이 된다.
  - 하지만 이러한 분리는 매우 빠르게 붕괴될 수 있다는 점은 분명하다.
    (개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면)
- `퍼사드(Facade)`
  - 퍼사드 패턴을 이용해 단일 컴포넌트에서 클래스로 경계를 정의한다.
  - 이 또한 일차원 경계와 동일하게 붕괴되기 쉬운 구조이다.

## 결론

아키텍처 경계를 부분적으로 만드는 각 방법은 나름의 비용과 장점을 가진다.

- 그리고 각 접근법은 해당 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있음을 명심하자
- 아키텍처 경계가 언제, 어디에 존재할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할임도 명심하자

# 25. 계층과 경계

- 간단한 게임 서비스를 기준으로 요구 사항을 추가하며 컴포넌트를 분리하는 과정을 담은 챕터
- 단순히 인터페이스를 분리해가는 과정이 담겨있음

## 결론

- 아키텍처 경계는 어디에나 존재하고 아키텍트로서 이 경계가 언제 필요한지 신중하게 파악해야할 것이다.
  - 그리고 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지해야한다.
  - 이와 동시에 이러한 경계가 무시되었다면 나중에 다시 추가하는 비용이 크다는 사실도 인지해야한다.
  - 포괄적인 테스트 스위트(test-suite)가 존재하고 리팩토링으로 단련되어 있어도 말이다.
- 그렇다면 아키텍트라면 어떻게 해야할까?
  - `YAGNI(You Aren’t Going to Need)`
    - 정말 필요한 작업만 하라
    - 추상화가 필요하리라고 미리 예측해서는 안되고
    - 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다는 것을 인지해야한다.
    - **최대한 늦게 결정하고 자주 결정해야한다.**
